<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class NMatrix - RDoc Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>ext/nmatrix/ruby_nmatrix.c
    <li>lib/nmatrix/blas.rb
    <li>lib/nmatrix/enumerate.rb
    <li>lib/nmatrix/io/market.rb
    <li>lib/nmatrix/io/mat5_reader.rb
    <li>lib/nmatrix/io/mat_reader.rb
    <li>lib/nmatrix/lapack.rb
    <li>lib/nmatrix/math.rb
    <li>lib/nmatrix/nmatrix.rb
    <li>lib/nmatrix/nvector.rb
    <li>lib/nmatrix/shortcuts.rb
    <li>lib/nmatrix/version.rb
    <li>lib/nmatrix/yale_functions.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link"><a href="Object.html">Object</a>
  
</nav>

    <!-- Included Modules -->
<nav id="includes-section" class="section">
  <h3 class="section-header">Included Modules</h3>

  <ul class="link-list">
  
  
    <li><span class="include">Enumerable</span>
  
  
  </ul>
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li ><a href="#method-c-5B-5D">::[]</a>
    
    <li ><a href="#method-c-bindgen">::bindgen</a>
    
    <li ><a href="#method-c-cindgen">::cindgen</a>
    
    <li ><a href="#method-c-diag">::diag</a>
    
    <li ><a href="#method-c-diagonal">::diagonal</a>
    
    <li ><a href="#method-c-diagonals">::diagonals</a>
    
    <li ><a href="#method-c-eye">::eye</a>
    
    <li ><a href="#method-c-findgen">::findgen</a>
    
    <li ><a href="#method-c-guess_dtype">::guess_dtype</a>
    
    <li ><a href="#method-c-identity">::identity</a>
    
    <li ><a href="#method-c-indgen">::indgen</a>
    
    <li ><a href="#method-c-load_file">::load_file</a>
    
    <li ><a href="#method-c-min_dtype">::min_dtype</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-c-ones">::ones</a>
    
    <li ><a href="#method-c-ones_like">::ones_like</a>
    
    <li ><a href="#method-c-random">::random</a>
    
    <li ><a href="#method-c-read">::read</a>
    
    <li ><a href="#method-c-seq">::seq</a>
    
    <li ><a href="#method-c-size">::size</a>
    
    <li ><a href="#method-c-upcast">::upcast</a>
    
    <li ><a href="#method-c-zeroes">::zeroes</a>
    
    <li ><a href="#method-c-zeros">::zeros</a>
    
    <li ><a href="#method-c-zeros_like">::zeros_like</a>
    
    <li ><a href="#method-i-3D-3D">#==</a>
    
    <li ><a href="#method-i-5B-5D">#[]</a>
    
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    
    <li ><a href="#method-i-abs">#abs</a>
    
    <li ><a href="#method-i-abs_dtype">#abs_dtype</a>
    
    <li ><a href="#method-i-alloc_svd_result">#alloc_svd_result</a>
    
    <li ><a href="#method-i-capacity">#capacity</a>
    
    <li ><a href="#method-i-cast">#cast</a>
    
    <li ><a href="#method-i-cast_full">#cast_full</a>
    
    <li ><a href="#method-i-col">#col</a>
    
    <li ><a href="#method-i-cols">#cols</a>
    
    <li ><a href="#method-i-column">#column</a>
    
    <li ><a href="#method-i-complex_conjugate">#complex_conjugate</a>
    
    <li ><a href="#method-i-complex_conjugate-21">#complex_conjugate!</a>
    
    <li ><a href="#method-i-conjugate_transpose">#conjugate_transpose</a>
    
    <li ><a href="#method-i-default_value">#default_value</a>
    
    <li ><a href="#method-i-dense-3F">#dense?</a>
    
    <li ><a href="#method-i-det">#det</a>
    
    <li ><a href="#method-i-det_exact">#det_exact</a>
    
    <li ><a href="#method-i-dim">#dim</a>
    
    <li ><a href="#method-i-dimensions">#dimensions</a>
    
    <li ><a href="#method-i-dot">#dot</a>
    
    <li ><a href="#method-i-dtype">#dtype</a>
    
    <li ><a href="#method-i-each">#each</a>
    
    <li ><a href="#method-i-each_along_dim">#each_along_dim</a>
    
    <li ><a href="#method-i-each_column">#each_column</a>
    
    <li ><a href="#method-i-each_layer">#each_layer</a>
    
    <li ><a href="#method-i-each_ordered_stored_with_indices">#each_ordered_stored_with_indices</a>
    
    <li ><a href="#method-i-each_rank">#each_rank</a>
    
    <li ><a href="#method-i-each_row">#each_row</a>
    
    <li ><a href="#method-i-each_stored_with_index">#each_stored_with_index</a>
    
    <li ><a href="#method-i-each_stored_with_indices">#each_stored_with_indices</a>
    
    <li ><a href="#method-i-each_with_indices">#each_with_indices</a>
    
    <li ><a href="#method-i-effective_dim">#effective_dim</a>
    
    <li ><a href="#method-i-effective_dimensions">#effective_dimensions</a>
    
    <li ><a href="#method-i-factorize_lu">#factorize_lu</a>
    
    <li ><a href="#method-i-flat_map">#flat_map</a>
    
    <li ><a href="#method-i-gesdd">#gesdd</a>
    
    <li ><a href="#method-i-gesvd">#gesvd</a>
    
    <li ><a href="#method-i-getrf-21">#getrf!</a>
    
    <li ><a href="#method-i-hermitian-3F">#hermitian?</a>
    
    <li ><a href="#method-i-initialize_copy">#initialize_copy</a>
    
    <li ><a href="#method-i-inject_along_dim">#inject_along_dim</a>
    
    <li ><a href="#method-i-inject_rank">#inject_rank</a>
    
    <li ><a href="#method-i-integer_dtype-3F">#integer_dtype?</a>
    
    <li ><a href="#method-i-inverse">#inverse</a>
    
    <li ><a href="#method-i-invert">#invert</a>
    
    <li ><a href="#method-i-invert-21">#invert!</a>
    
    <li ><a href="#method-i-is_ref-3F">#is_ref?</a>
    
    <li ><a href="#method-i-laswp">#laswp</a>
    
    <li ><a href="#method-i-laswp-21">#laswp!</a>
    
    <li ><a href="#method-i-layer">#layer</a>
    
    <li ><a href="#method-i-list-3F">#list?</a>
    
    <li ><a href="#method-i-map">#map</a>
    
    <li ><a href="#method-i-map-21">#map!</a>
    
    <li ><a href="#method-i-max">#max</a>
    
    <li ><a href="#method-i-mean">#mean</a>
    
    <li ><a href="#method-i-min">#min</a>
    
    <li ><a href="#method-i-nvector-3F">#nvector?</a>
    
    <li ><a href="#method-i-offset">#offset</a>
    
    <li ><a href="#method-i-permute_columns">#permute_columns</a>
    
    <li ><a href="#method-i-permute_columns-21">#permute_columns!</a>
    
    <li ><a href="#method-i-rank">#rank</a>
    
    <li ><a href="#method-i-reduce_along_dim">#reduce_along_dim</a>
    
    <li ><a href="#method-i-row">#row</a>
    
    <li ><a href="#method-i-rows">#rows</a>
    
    <li ><a href="#method-i-shape">#shape</a>
    
    <li ><a href="#method-i-shuffle">#shuffle</a>
    
    <li ><a href="#method-i-shuffle-21">#shuffle!</a>
    
    <li ><a href="#method-i-size">#size</a>
    
    <li ><a href="#method-i-slice">#slice</a>
    
    <li ><a href="#method-i-std">#std</a>
    
    <li ><a href="#method-i-stype">#stype</a>
    
    <li ><a href="#method-i-sum">#sum</a>
    
    <li ><a href="#method-i-supershape">#supershape</a>
    
    <li ><a href="#method-i-symmetric-3F">#symmetric?</a>
    
    <li ><a href="#method-i-to_a">#to_a</a>
    
    <li ><a href="#method-i-to_f">#to_f</a>
    
    <li ><a href="#method-i-to_flat_a">#to_flat_a</a>
    
    <li ><a href="#method-i-to_flat_array">#to_flat_array</a>
    
    <li ><a href="#method-i-to_h">#to_h</a>
    
    <li ><a href="#method-i-to_hash">#to_hash</a>
    
    <li ><a href="#method-i-transpose">#transpose</a>
    
    <li ><a href="#method-i-variance">#variance</a>
    
    <li ><a href="#method-i-vector-3F">#vector?</a>
    
    <li ><a href="#method-i-write">#write</a>
    
    <li ><a href="#method-i-yale-3F">#yale?</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./CONTRIBUTING_md.html">CONTRIBUTING</a>
  
    <li class="file"><a href="./History_txt.html">History</a>
  
    <li class="file"><a href="./LICENSE_txt.html">LICENSE</a>
  
    <li class="file"><a href="./README_rdoc.html">README</a>
  
    <li class="file"><a href="./ext/nmatrix/binary_format_txt.html">binary_format</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./Array.html">Array</a>
  
    <li><a href="./DataTypeError.html">DataTypeError</a>
  
    <li><a href="./N.html">N</a>
  
    <li><a href="./NMatrix.html">NMatrix</a>
  
    <li><a href="./NMatrix/BLAS.html">NMatrix::BLAS</a>
  
    <li><a href="./NMatrix/IO.html">NMatrix::IO</a>
  
    <li><a href="./NMatrix/IO/Market.html">NMatrix::IO::Market</a>
  
    <li><a href="./NMatrix/IO/Matlab.html">NMatrix::IO::Matlab</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader.html">NMatrix::IO::Matlab::Mat5Reader</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Compressed.html">NMatrix::IO::Matlab::Mat5Reader::Compressed</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Element.html">NMatrix::IO::Matlab::Mat5Reader::Element</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html">NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Header.html">NMatrix::IO::Matlab::Mat5Reader::Header</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/MatrixData.html">NMatrix::IO::Matlab::Mat5Reader::MatrixData</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/RawElement.html">NMatrix::IO::Matlab::Mat5Reader::RawElement</a>
  
    <li><a href="./NMatrix/IO/Matlab/Mat5Reader/Tag.html">NMatrix::IO::Matlab::Mat5Reader::Tag</a>
  
    <li><a href="./NMatrix/IO/Matlab/MatReader.html">NMatrix::IO::Matlab::MatReader</a>
  
    <li><a href="./NMatrix/LAPACK.html">NMatrix::LAPACK</a>
  
    <li><a href="./NMatrix/YaleFunctions.html">NMatrix::YaleFunctions</a>
  
    <li><a href="./NVector.html">NVector</a>
  
    <li><a href="./NVector.html">NVector</a>
  
    <li><a href="./Object.html">Object</a>
  
    <li><a href="./RSpec.html">RSpec</a>
  
    <li><a href="./RSpec/Matchers.html">RSpec::Matchers</a>
  
    <li><a href="./RSpec/Matchers/BuiltIn.html">RSpec::Matchers::BuiltIn</a>
  
    <li><a href="./RSpec/Matchers/BuiltIn/BeWithin.html">RSpec::Matchers::BuiltIn::BeWithin</a>
  
    <li><a href="./StorageTypeError.html">StorageTypeError</a>
  
    <li><a href="./unknown.html">unknown</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class NMatrix</h1>

  <div id="description" class="description">
    
  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="VERSION">VERSION
        
        <dd class="description"><p>Note that the format of the <a href="NMatrix.html#VERSION">VERSION</a>
string is needed for <a href="NMatrix.html">NMatrix</a> native IO. If you
change the format, please make sure that native IO can still understand
NMatrix::VERSION.</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="method-c-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            NMatrix[array-of-arrays, dtype = nil]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>You can use the old <code>N</code> constant in this way:</p>

<pre>N = NMatrix
N[1, 2, 3]</pre>

<p><a href="NMatrix.html">NMatrix</a> needs to have a succinct way to create a
matrix by specifying the components directly. This is very useful for using
it as an advanced calculator, it is useful for learning how to use, for
testing language features and for developing algorithms.</p>

<p>The NMatrix::[] method provides a way to create a matrix in a way that is
compact and natural. The components are specified using Ruby array syntax.
Optionally, one can specify a dtype as the last parameter (default is
:float64).</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">NMatrix</span>[ <span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span> ]          =<span class="ruby-operator">&gt;</span>  <span class="ruby-value">1.0</span>  <span class="ruby-value">2.0</span>  <span class="ruby-value">3.0</span>  <span class="ruby-value">4.0</span>

<span class="ruby-identifier">a</span> = <span class="ruby-constant">NMatrix</span>[ <span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span> ]  =<span class="ruby-operator">&gt;</span>  <span class="ruby-value">1</span>  <span class="ruby-value">2</span>  <span class="ruby-value">3</span>  <span class="ruby-value">4</span>

<span class="ruby-identifier">a</span> = <span class="ruby-constant">NMatrix</span>[ [<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>], [<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>] ] =<span class="ruby-operator">&gt;</span>  <span class="ruby-value">1.0</span>  <span class="ruby-value">2.0</span>  <span class="ruby-value">3.0</span>
                                    <span class="ruby-value">3.0</span>  <span class="ruby-value">4.0</span>  <span class="ruby-value">5.0</span>
</pre>

<p>SYNTAX COMPARISON:</p>

<pre>MATLAB:         a = [ [1 2 3] ; [4 5 6] ]   or  [ 1 2 3 ; 4 5 6 ]
IDL:                    a = [ [1,2,3] , [4,5,6] ]
NumPy:          a = array( [1,2,3], [4,5,6] )

SciRuby:      a = NMatrix[ [1,2,3], [4,5,6] ]
Ruby array:   a =  [ [1,2,3], [4,5,6] ]</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 87</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-identifier">options</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">pop</span> <span class="ruby-operator">:</span> {}

  <span class="ruby-comment"># First find the dimensions of the array.</span>
  <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>
  <span class="ruby-identifier">shape</span> = []
  <span class="ruby-identifier">row</span> = <span class="ruby-identifier">params</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
    <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">row</span>.<span class="ruby-identifier">length</span>
    <span class="ruby-identifier">row</span> = <span class="ruby-identifier">row</span>[<span class="ruby-value">0</span>]
    <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># A row vector should be stored as 1xN, not N</span>
  <span class="ruby-comment">#shape.unshift(1) if shape.size == 1</span>

  <span class="ruby-comment"># Then flatten the array.</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">params</span>.<span class="ruby-identifier">flatten</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- 5B-5D-source -->
          
        </div>

        

        
      </div><!-- 5B-5D-method -->

    
      <div id="method-c-bindgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            bindgen(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a byte <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, dtype: :byte)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; Shape of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:byte</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="bindgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 366</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">bindgen</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:byte</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- bindgen-source -->
          
        </div>

        

        
      </div><!-- bindgen-method -->

    
      <div id="method-c-cindgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cindgen(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a complex <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, dtype: :complex64)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; Shape of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:complex64</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="cindgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 381</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cindgen</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:complex64</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- cindgen-source -->
          
        </div>

        

        
      </div><!-- cindgen-method -->

    
      <div id="method-c-diag" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">diag</span><span
            class="method-args">(entries, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-diagonal">diagonal</a>
        </div>
        
      </div><!-- diag-method -->

    
      <div id="method-c-diagonal" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            diagonals(array) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            diagonals(array, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with specified diagonals.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>entries</code> -&gt; <a href="Array.html">Array</a> containing input
values for diagonal matrix</p>
</li><li>
<p><code>options</code> -&gt; (optional) Hash with options for
NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with specified diagonal values.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">diagonal</span>([<span class="ruby-value">1.0</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>]) <span class="ruby-comment"># =&gt; 1.0 0.0 0.0 0.0</span>
                                   <span class="ruby-value">0.0</span> <span class="ruby-value">2.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span>
                                   <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">3.0</span> <span class="ruby-value">0.0</span>
                                   <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">0.0</span> <span class="ruby-value">4.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">diagonal</span>([<span class="ruby-value">1</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt; 1 0 0 0</span>
                                                <span class="ruby-value">0</span> <span class="ruby-value">2</span> <span class="ruby-value">0</span> <span class="ruby-value">0</span>
                                                <span class="ruby-value">0</span> <span class="ruby-value">0</span> <span class="ruby-value">3</span> <span class="ruby-value">0</span>
                                                <span class="ruby-value">0</span> <span class="ruby-value">0</span> <span class="ruby-value">0</span> <span class="ruby-value">4</span>
</pre>
          
          

          
          <div class="method-source-code" id="diagonal-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">diagonal</span>(<span class="ruby-identifier">entries</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">entries</span>.<span class="ruby-identifier">size</span>,
                    {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">guess_dtype</span>(<span class="ruby-identifier">entries</span>[<span class="ruby-value">0</span>]), <span class="ruby-value">:capacity</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)
                   )
  <span class="ruby-identifier">entries</span>.<span class="ruby-identifier">each_with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">n</span>, <span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">m</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">n</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">m</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- diagonal-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-diag">diag</a>, <a href="NMatrix.html#method-c-diagonals">diagonals</a>
        </div>
        

        
      </div><!-- diagonal-method -->

    
      <div id="method-c-diagonals" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">diagonals</span><span
            class="method-args">(entries, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-diagonal">diagonal</a>
        </div>
        
      </div><!-- diagonals-method -->

    
      <div id="method-c-eye" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            eye(shape, stype: stype, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates an identity matrix (square matrix rank 2).</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>size</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>An identity matrix.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt;   1.0   0.0   0.0</span>
                      <span class="ruby-value">0.0</span>   <span class="ruby-value">1.0</span>   <span class="ruby-value">0.0</span>
                      <span class="ruby-value">0.0</span>   <span class="ruby-value">0.0</span>   <span class="ruby-value">1.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">3</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;   1   0   0</span>
                                     <span class="ruby-value">0</span>   <span class="ruby-value">1</span>   <span class="ruby-value">0</span>
                                     <span class="ruby-value">0</span>   <span class="ruby-value">0</span>   <span class="ruby-value">1</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">eye</span>(<span class="ruby-value">2</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">yale</span>) <span class="ruby-comment"># =&gt;   1   0</span>
                                                   <span class="ruby-value">0</span>   <span class="ruby-value">1</span>
</pre>
          
          

          
          <div class="method-source-code" id="eye-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">eye</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-comment"># Fill the diagonal with 1&#39;s.</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">shape</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">m</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">m</span>[<span class="ruby-identifier">i</span>, <span class="ruby-identifier">i</span>] = <span class="ruby-value">1</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">m</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- eye-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-identity">identity</a>
        </div>
        

        
      </div><!-- eye-method -->

    
      <div id="method-c-findgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            findgen(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns a float <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, dtype: :float32)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; Shape of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:float32</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="findgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 351</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">findgen</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:float32</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- findgen-source -->
          
        </div>

        

        
      </div><!-- findgen-method -->

    
      <div id="method-c-guess_dtype" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">guess_dtype</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Guess the dtype given a Ruby VALUE and return it as a symbol.</p>

<p>Not to be confused with nm_dtype_guess, which returns an nm::dtype_t. (This
calls that.)</p>
          
          

          
          <div class="method-source-code" id="guess_dtype-source">
            <pre>static VALUE nm_guess_dtype(VALUE self, VALUE v) {
  return ID2SYM(rb_intern(DTYPE_NAMES[nm_dtype_guess(v)]));
}</pre>
          </div><!-- guess_dtype-source -->
          
        </div>

        

        
      </div><!-- guess_dtype-method -->

    
      <div id="method-c-identity" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">identity</span><span
            class="method-args">(shape, opts={})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-eye">eye</a>
        </div>
        
      </div><!-- identity-method -->

    
      <div id="method-c-indgen" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            indgen(size) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an integer <a href="NMatrix.html">NMatrix</a>. Equivalent to
<code>seq(n, dtype: :int32)</code>.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; Shape of the sequence.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> with dtype <code>:int32</code>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="indgen-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 336</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">indgen</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-value">:int32</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- indgen-source -->
          
        </div>

        

        
      </div><!-- indgen-method -->

    
      <div id="method-c-load_file" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            load_file(path) &rarr; Mat5Reader
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>path</code> -&gt; The path to a version 5 .mat file.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A Mat5Reader object.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="load_file-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 65</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">load_file</span>(<span class="ruby-identifier">file_path</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">IO</span><span class="ruby-operator">::</span><span class="ruby-constant">Mat5Reader</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">file_path</span>, <span class="ruby-string">&#39;rb&#39;</span>)).<span class="ruby-identifier">to_ruby</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- load_file-source -->
          
        </div>

        

        
      </div><!-- load_file-method -->

    
      <div id="method-c-min_dtype" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">min_dtype</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.</p>
          
          

          
          <div class="method-source-code" id="min_dtype-source">
            <pre>static VALUE nm_min_dtype(VALUE self, VALUE v) {
  return ID2SYM(rb_intern(DTYPE_NAMES[nm_dtype_min(v)]));
}</pre>
          </div><!-- min_dtype-source -->
          
        </div>

        

        
      </div><!-- min_dtype-method -->

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_value) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_array) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_value, options) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            new(shape, initial_array, options) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a new <a href="NMatrix.html">NMatrix</a>.</p>

<p>The only mandatory argument is shape, which may be a positive integer or an
array of positive integers.</p>

<p>It is recommended that you supply an initialization value or array of
values. Without one, Yale and List matrices will be initialized to 0; and
dense matrices will be undefined.</p>

<p>Additional options may be provided using keyword arguments. The keywords
are +:dtype, <code>:stype</code>, <code>:capacity</code>, and
<code>:default</code>. Only Yale uses a capacity argument, which is used to
reserve the initial size of its storage vectors. List and Yale both accept
a default value (which itself defaults to 0). This default is taken from
the initial value if such a value is given; it is more likely to be
required when an initial array is provided.</p>

<p>The storage type, or stype, is used to specify whether we want a
<code>:dense</code>, <code>:list</code>, or <code>:yale</code> matrix;
dense is the default.</p>

<p>The data type, or dtype, can be one of: :byte, :int8, :int16, :int32,
:int64, :float32, :float64, :complex64, :complex128, :rational128, or
:object. The constructor will attempt to guess it from the initial
value/array/default provided, if any. Otherwise, the default is :object,
which stores any type of Ruby object.</p>

<p>In addition to the above, there is a legacy constructor from the alpha
version. To use that version, you must be providing exactly four arguments.
It is now deprecated.</p>

<p>There is one additional constructor for advanced users, which takes seven
arguments and is only for creating Yale matrices with known IA, JA, and A
arrays. This is used primarily internally for IO, e.g., reading Matlab
matrices, which are stored in old Yale (not our Yale) format. But be
careful; there are no overflow warnings. All of these constructors are
defined for power-users. Everyone else should probably resort to the
shortcut functions defined in shortcuts.rb.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE nm_init(int argc, VALUE* argv, VALUE nm) {

  if (argc &lt;= 3) { // Call the new constructor unless all four arguments are given (or the 7-arg version is given)
        return nm_init_new_version(argc, argv, nm);
  }

  /* First, determine stype (dense by default) */
  nm::stype_t stype;
  size_t  offset = 0;

  if (!SYMBOL_P(argv[0]) &amp;&amp; TYPE(argv[0]) != T_STRING) {
    stype = nm::DENSE_STORE;

  } else {
    // 0: String or Symbol
    stype  = interpret_stype(argv[0]);
    offset = 1;
  }

  // If there are 7 arguments and Yale, refer to a different init function with fewer sanity checks.
  if (argc == 7) {
        if (stype == nm::YALE_STORE) {
                        return nm_init_yale_from_old_yale(argv[1], argv[2], argv[3], argv[4], argv[5], argv[6], nm);

                } else {
                        rb_raise(rb_eArgError, &quot;Expected 2-4 arguments (or 7 for internal Yale creation)&quot;);
                }
  }

        // 1: Array or Fixnum
        size_t dim;
  size_t* shape = interpret_shape(argv[offset], &amp;dim);

  // 2-3: dtype
  nm::dtype_t dtype = interpret_dtype(argc-1-offset, argv+offset+1, stype);

  size_t init_cap = 0, init_val_len = 0;
  void* init_val  = NULL;
  if (!SYMBOL_P(argv[1+offset]) || TYPE(argv[1+offset]) == T_ARRAY) {
        // Initial value provided (could also be initial capacity, if yale).

    if (stype == nm::YALE_STORE &amp;&amp; NM_RUBYVAL_IS_NUMERIC(argv[1+offset])) {
      init_cap = FIX2UINT(argv[1+offset]);

    } else {
        // 4: initial value / dtype
      init_val = interpret_initial_value(argv[1+offset], dtype);

      if (TYPE(argv[1+offset]) == T_ARRAY)      init_val_len = RARRAY_LEN(argv[1+offset]);
      else                                  init_val_len = 1;
    }

  } else {
        // DType is RUBYOBJ.

    if (stype == nm::DENSE_STORE) {
        /*
         * No need to initialize dense with any kind of default value unless it&#39;s
         * an RUBYOBJ matrix.
         */
      if (dtype == nm::RUBYOBJ) {
        // Pretend [nil] was passed for RUBYOBJ.
        init_val = ALLOC(VALUE);
        *(VALUE*)init_val = Qnil;

        init_val_len = 1;

      } else {
        init_val = NULL;
      }
    } else if (stype == nm::LIST_STORE) {
        init_val = ALLOC_N(char, DTYPE_SIZES[dtype]);
      std::memset(init_val, 0, DTYPE_SIZES[dtype]);
    }
  }

  // TODO: Update to allow an array as the initial value.
        NMATRIX* nmatrix;
  UnwrapNMatrix(nm, nmatrix);

  nmatrix-&gt;stype = stype;

  switch (stype) {
        case nm::DENSE_STORE:
                nmatrix-&gt;storage = (STORAGE*)nm_dense_storage_create(dtype, shape, dim, init_val, init_val_len);
                break;

        case nm::LIST_STORE:
                nmatrix-&gt;storage = (STORAGE*)nm_list_storage_create(dtype, shape, dim, init_val);
                break;

        case nm::YALE_STORE:
                nmatrix-&gt;storage = (STORAGE*)nm_yale_storage_create(dtype, shape, dim, init_cap);
                nm_yale_storage_init((YALE_STORAGE*)(nmatrix-&gt;storage), NULL);
                break;
  }

  return nm;
}</pre>
          </div><!-- new-source -->
          
        </div>

        

        
      </div><!-- new-method -->

    
      <div id="method-c-ones" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            ones(shape, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with ones.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the shape.</p>
</li><li>
<p><code>opts</code> -&gt; (optional) Hash of options from NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with ones.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>([<span class="ruby-value">1</span>, <span class="ruby-value">3</span>]) <span class="ruby-comment"># =&gt;  1.0   1.0   1.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  1  1  1</span>
                                          <span class="ruby-value">1</span>  <span class="ruby-value">1</span>  <span class="ruby-value">1</span>
</pre>
          
          

          
          <div class="method-source-code" id="ones-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ones</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-value">1</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>, <span class="ruby-value">:default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div><!-- ones-source -->
          
        </div>

        

        
      </div><!-- ones-method -->

    
      <div id="method-c-ones_like" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ones_like(nm) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of ones with the same dtype and shape as the provided
matrix.</p>

<p>@param [NMatrix] nm the nmatrix whose dtype and shape will be used @return
[NMatrix] a new nmatrix filled with ones.</p>
          
          

          
          <div class="method-source-code" id="ones_like-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 172</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">ones_like</span>(<span class="ruby-identifier">nm</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">ones</span>(<span class="ruby-identifier">nm</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">capacity</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- ones_like-source -->
          
        </div>

        

        
      </div><!-- ones_like-method -->

    
      <div id="method-c-random" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            random(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a <code>:dense</code> <a href="NMatrix.html">NMatrix</a> with
random numbers between 0 and 1 generated by +Random::rand+. The parameter
is the dimension of the matrix.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with random values.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">random</span>([<span class="ruby-value">2</span>, <span class="ruby-value">2</span>]) <span class="ruby-comment"># =&gt; 0.4859439730644226   0.1783195585012436</span>
                            <span class="ruby-value">0.23193766176700592</span>  <span class="ruby-value">0.4503345191478729</span>
</pre>
          
          

          
          <div class="method-source-code" id="random-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">random</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span>={})
  <span class="ruby-identifier">rng</span> = <span class="ruby-constant">Random</span>.<span class="ruby-identifier">new</span>

  <span class="ruby-identifier">random_values</span> = []

  <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>).<span class="ruby-identifier">times</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">random_values</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">rng</span>.<span class="ruby-identifier">rand</span> }

  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">random_values</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>, <span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:dense</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div><!-- random-source -->
          
        </div>

        

        
      </div><!-- random-method -->

    
      <div id="method-c-read" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">read</span><span
            class="method-args">(p1, p2 = v2)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file reader for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we aren&#39;t going to check very carefully
(in other words, this function should generally be called from a Ruby
helper method).</p>

<p>Note that currently, this function will by default refuse to read files
that are newer than your version of <a href="NMatrix.html">NMatrix</a>. To
force an override, set the second argument to anything other than nil.</p>

<p>Returns an <a href="NMatrix.html">NMatrix</a> Ruby object.</p>
          
          

          
          <div class="method-source-code" id="read-source">
            <pre>static VALUE nm_read(int argc, VALUE* argv, VALUE self) {
  using std::ifstream;

  VALUE file, force_;

  // Read the arguments
  rb_scan_args(argc, argv, &quot;11&quot;, &amp;file, &amp;force_);
  bool force   = (force_ != Qnil &amp;&amp; force_ != Qfalse);


  if (!RB_FILE_EXISTS(file)) { // FIXME: Errno::ENOENT
    rb_raise(rb_get_errno_exc(&quot;ENOENT&quot;), &quot;%s&quot;, RSTRING_PTR(file));
  }

  // Open a file stream
  ifstream f(RSTRING_PTR(file), std::ios::in | std::ios::binary);

  uint16_t major, minor, release;
  get_version_info(major, minor, release); // compare to NMatrix version

  uint16_t fmajor, fminor, frelease, null16;

  // READ FIRST 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fmajor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;fminor),   sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;frelease), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16),   sizeof(uint16_t));

  int ver  = major * 10000 + minor * 100 + release,
      fver = fmajor * 10000 + fminor * 100 + release;
  if (fver &gt; ver &amp;&amp; force == false) {
    rb_raise(rb_eIOError, &quot;File was created in newer version of NMatrix than current&quot;);
  }
  if (null16 != 0) fprintf(stderr, &quot;Warning: Expected zero padding was not zero\n&quot;);

  uint8_t dt, st, it, sm;
  uint16_t dim;

  // READ SECOND 64-BIT BLOCK
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dt), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;st), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;it), sizeof(uint8_t)); // FIXME: should tell how few bytes indices are stored as
  f.read(reinterpret_cast&lt;char*&gt;(&amp;sm), sizeof(uint8_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;null16), sizeof(uint16_t));
  f.read(reinterpret_cast&lt;char*&gt;(&amp;dim), sizeof(uint16_t));

  if (null16 != 0) fprintf(stderr, &quot;Warning: Expected zero padding was not zero\n&quot;);
  nm::stype_t stype = static_cast&lt;nm::stype_t&gt;(st);
  nm::dtype_t dtype = static_cast&lt;nm::dtype_t&gt;(dt);
  nm::symm_t  symm  = static_cast&lt;nm::symm_t&gt;(sm);
  //nm::itype_t itype = static_cast&lt;nm::itype_t&gt;(it);

  // READ NEXT FEW 64-BIT BLOCKS
  size_t* shape = ALLOC_N(size_t, dim);
  read_padded_shape(f, dim, shape);

  STORAGE* s;
  if (stype == nm::DENSE_STORE) {
    s = nm_dense_storage_create(dtype, shape, dim, NULL, 0);

    read_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(s), symm, dtype);

  } else if (stype == nm::YALE_STORE) {
    uint32_t ndnz, length;

    // READ YALE-SPECIFIC 64-BIT BLOCK
    f.read(reinterpret_cast&lt;char*&gt;(&amp;ndnz),     sizeof(uint32_t));
    f.read(reinterpret_cast&lt;char*&gt;(&amp;length),   sizeof(uint32_t));

    s = nm_yale_storage_create(dtype, shape, dim, length); // set length as init capacity

    read_padded_yale_elements(f, reinterpret_cast&lt;YALE_STORAGE*&gt;(s), length, symm, dtype);
  } else {
    rb_raise(nm_eStorageTypeError, &quot;please convert to yale or dense before saving&quot;);
  }

  NMATRIX* nm = nm_create(stype, s);

  // Return the appropriate matrix object (Ruby VALUE)
  // FIXME: This should probably return CLASS_OF(self) instead of cNMatrix, but I don&#39;t know how that works for
  // FIXME: class methods.
  switch(stype) {
  case nm::DENSE_STORE:
  case nm::YALE_STORE:
    return Data_Wrap_Struct(cNMatrix, nm_mark, nm_delete, nm);
  default: // this case never occurs (due to earlier rb_raise)
    return Qnil;
  }

}</pre>
          </div><!-- read-source -->
          
        </div>

        

        
      </div><!-- read-method -->

    
      <div id="method-c-seq" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            seq(shape, options) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a matrix filled with a sequence of integers starting at zero.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>options</code> -&gt; (optional) Options permissible for
NMatrix#initialize</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with values 0 through
<code>size</code>.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt;   0   1</span>
              <span class="ruby-value">2</span>   <span class="ruby-value">3</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">seq</span>([<span class="ruby-value">3</span>, <span class="ruby-value">3</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">float32</span>) <span class="ruby-comment"># =&gt;  0.0  1.0  2.0</span>
                                    <span class="ruby-value">3.0</span>  <span class="ruby-value">4.0</span>  <span class="ruby-value">5.0</span>
                                    <span class="ruby-value">6.0</span>  <span class="ruby-value">7.0</span>  <span class="ruby-value">8.0</span>
</pre>
          
          

          
          <div class="method-source-code" id="seq-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 316</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">seq</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">options</span>={})

  <span class="ruby-comment"># Construct the values of the final matrix based on the dimension.</span>
  <span class="ruby-identifier">values</span> = (<span class="ruby-value">0</span> <span class="ruby-operator">...</span> <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>)).<span class="ruby-identifier">to_a</span>

  <span class="ruby-comment"># It&#39;ll produce :int32, except if a dtype is provided.</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">values</span>, {<span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:dense</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">options</span>))
<span class="ruby-keyword">end</span></pre>
          </div><!-- seq-source -->
          
        </div>

        

        
      </div><!-- seq-method -->

    
      <div id="method-c-size" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">size</span><span
            class="method-args">(shape)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the size of an <a href="NMatrix.html">NMatrix</a> of a given
shape.</p>
          
          

          
          <div class="method-source-code" id="size-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 71</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>(<span class="ruby-identifier">shape</span>)
  <span class="ruby-identifier">shape</span> = [<span class="ruby-identifier">shape</span>,<span class="ruby-identifier">shape</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Array</span>)
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>).<span class="ruby-identifier">inject</span>(<span class="ruby-value">1</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">x</span> <span class="ruby-operator">*</span> <span class="ruby-identifier">shape</span>[<span class="ruby-identifier">i</span>] }
<span class="ruby-keyword">end</span></pre>
          </div><!-- size-source -->
          
        </div>

        

        
      </div><!-- size-method -->

    
      <div id="method-c-upcast" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upcast(first_dtype, second_dtype) &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Given a binary operation between types t1 and t2, what type will be
returned?</p>

<p>This is a singleton method on <a href="NMatrix.html">NMatrix</a>, e.g., <a
href="NMatrix.html#method-c-upcast">::upcast</a>(:int32, :int64)</p>
          
          

          
          <div class="method-source-code" id="upcast-source">
            <pre>static VALUE nm_upcast(VALUE self, VALUE t1, VALUE t2) {

  nm::dtype_t d1    = nm_dtype_from_rbsymbol(t1),
              d2    = nm_dtype_from_rbsymbol(t2);

  return ID2SYM(rb_intern( DTYPE_NAMES[ Upcast[d1][d2] ] ));
}</pre>
          </div><!-- upcast-source -->
          
        </div>

        

        
      </div><!-- upcast-method -->

    
      <div id="method-c-zeroes" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">zeroes</span><span
            class="method-args">(shape, opts = {})</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-c-zeros">zeros</a>
        </div>
        
      </div><!-- zeroes-method -->

    
      <div id="method-c-zeros" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape, dtype: dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros(shape, dtype: dtype, stype: stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of zeros with the dimensions supplied as parameters.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>shape</code> -&gt; <a href="Array.html">Array</a> (or integer for
square matrix) specifying the dimensions.</p>
</li><li>
<p><code>dtype</code> -&gt; (optional) Default is <code>:float64</code></p>
</li><li>
<p><code>stype</code> -&gt; (optional) Default is <code>:dense</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p><a href="NMatrix.html">NMatrix</a> filled with zeros.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt;  0.0   0.0</span>
                       <span class="ruby-value">0.0</span>   <span class="ruby-value">0.0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>([<span class="ruby-value">2</span>, <span class="ruby-value">3</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  0  0  0</span>
                                           <span class="ruby-value">0</span>  <span class="ruby-value">0</span>  <span class="ruby-value">0</span>

<span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>([<span class="ruby-value">1</span>, <span class="ruby-value">5</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  0  0  0  0  0</span>
</pre>
          
          

          
          <div class="method-source-code" id="zeros-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">opts</span> = {})
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>, <span class="ruby-value">0</span>, {<span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">:float64</span>}.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>))
<span class="ruby-keyword">end</span></pre>
          </div><!-- zeros-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-c-zeroes">zeroes</a>
        </div>
        

        
      </div><!-- zeros-method -->

    
      <div id="method-c-zeros_like" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            zeros_like(nm) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Creates a new matrix of zeros with the same stype, dtype, and shape as the
provided matrix.</p>

<p>@param [NMatrix] nm the nmatrix whose stype, dtype, and shape will be used
@return [NMatrix] a new nmatrix filled with zeros.</p>
          
          

          
          <div class="method-source-code" id="zeros_like-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 186</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">zeros_like</span>(<span class="ruby-identifier">nm</span>)
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">zeros</span>(<span class="ruby-identifier">nm</span>.<span class="ruby-identifier">shape</span>, <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">dtype</span>, <span class="ruby-identifier">stype</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">capacity</span><span class="ruby-operator">:</span> <span class="ruby-identifier">nm</span>.<span class="ruby-identifier">capacity</span>, <span class="ruby-identifier">default</span><span class="ruby-operator">:</span> <span class="ruby-value">0</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- zeros_like-source -->
          
        </div>

        

        
      </div><!-- zeros_like-method -->

    
    </section><!-- public-class-method-details -->
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-3D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">==</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Equality operator. Returns a single true or false value indicating whether
the matrices are equivalent.</p>

<p>For elementwise, use =~ instead.</p>

<p>This method will raise an exception if dimensions do not match.</p>
          
          

          
          <div class="method-source-code" id="3D-3D-source">
            <pre>static VALUE nm_eqeq(VALUE left, VALUE right) {
  NMATRIX *l, *r;

  CheckNMatrixType(left);
  CheckNMatrixType(right);

  UnwrapNMatrix(left, l);
  UnwrapNMatrix(right, r);

  if (l-&gt;stype != r-&gt;stype)
    rb_raise(rb_eNotImpError, &quot;comparison between different matrix stypes not yet implemented&quot;);

  bool result = false;

  switch(l-&gt;stype) {
  case nm::DENSE_STORE:
    result = nm_dense_storage_eqeq(l-&gt;storage, r-&gt;storage);
    break;
  case nm::LIST_STORE:
    result = nm_list_storage_eqeq(l-&gt;storage, r-&gt;storage);
    break;
  case nm::YALE_STORE:
    result = nm_yale_storage_eqeq(l-&gt;storage, r-&gt;storage);
    break;
  }

  return result ? Qtrue : Qfalse;
}</pre>
          </div><!-- 3D-3D-source -->
          
        </div>

        

        
      </div><!-- 3D-3D-method -->

    
      <div id="method-i-5B-5D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            matrix[indices] &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates by reference.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>[<span class="ruby-value">3</span>,<span class="ruby-value">3</span>]  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>] <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE nm_mref(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(const STORAGE*, SLICE*) = {
    nm_dense_storage_ref,
    nm_list_storage_ref,
    nm_yale_storage_ref
  };
  return nm_xslice(argc, argv, ttable[NM_STYPE(self)], nm_delete_ref, self);
}</pre>
          </div><!-- 5B-5D-source -->
          
        </div>

        

        
      </div><!-- 5B-5D-method -->

    
      <div id="method-i-5B-5D-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">[]=</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Modify the contents of an <a href="NMatrix.html">NMatrix</a> in the given
cell</p>

<pre>n[3,3] = 5.0</pre>

<p>Also returns the new contents, so you can chain:</p>

<pre>n[3,3] = n[2,3] = 5.0</pre>
          
          

          
          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE nm_mset(int argc, VALUE* argv, VALUE self) {
  size_t dim = NM_DIM(self); // last arg is the value

  if ((size_t)(argc) &gt; NM_DIM(self)+1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for %u)&quot;, argc, effective_dim(NM_STORAGE(self))+1);
  } else {
    SLICE* slice = get_slice(dim, argc-1, argv, NM_STORAGE(self)-&gt;shape);

    static void (*ttable[nm::NUM_STYPES])(VALUE, SLICE*, VALUE) = {
      nm_dense_storage_set,
      nm_list_storage_set,
      nm_yale_storage_set
    };

    ttable[NM_STYPE(self)](self, slice, argv[argc-1]);

    free_slice(slice);

    return argv[argc-1];
  }
  return Qnil;
}</pre>
          </div><!-- 5B-5D-3D-source -->
          
        </div>

        

        
      </div><!-- 5B-5D-3D-method -->

    
      <div id="method-i-abs" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Maps all values in a matrix to their absolute values.</p>
          
          

          
          <div class="method-source-code" id="abs-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 401</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">abs</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_map__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:list</span>
    <span class="ruby-comment"># FIXME: Need __list_map_stored__, but this will do for now.</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__list_map_merged_stored__</span>(<span class="ruby-keyword">nil</span>, <span class="ruby-keyword">nil</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">dummy</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__yale_map_stored__</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">v</span>.<span class="ruby-identifier">abs</span> }
  <span class="ruby-keyword">end</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">abs_dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- abs-source -->
          
        </div>

        

        
      </div><!-- abs-method -->

    
      <div id="method-i-abs_dtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            abs_dtype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the dtype of the result of a call to <a
href="NMatrix.html#method-i-abs">abs</a>. In most cases, this is the same
as dtype; it should only differ for :complex64 (where it&#39;s :float32)
and :complex128 (:float64).</p>
          
          

          
          <div class="method-source-code" id="abs_dtype-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 385</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">abs_dtype</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:complex64</span>
    <span class="ruby-value">:float32</span>
  <span class="ruby-keyword">elsif</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:complex128</span>
    <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- abs_dtype-source -->
          
        </div>

        

        
      </div><!-- abs_dtype-method -->

    
      <div id="method-i-alloc_svd_result" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">alloc_svd_result</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="alloc_svd_result-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 100</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">alloc_svd_result</span>
  [
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>),
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>([<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>],<span class="ruby-value">1</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>),
    <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">dtype</span><span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
  ]
<span class="ruby-keyword">end</span></pre>
          </div><!-- alloc_svd_result-source -->
          
        </div>

        

        
      </div><!-- alloc_svd_result-method -->

    
      <div id="method-i-capacity" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">capacity</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Find the capacity of an <a href="NMatrix.html">NMatrix</a>. The capacity
only differs from the size for Yale matrices, which occasionally allocate
more space than they need. For list and dense, capacity gives the number of
elements in the matrix.</p>

<p>If you call this on a slice, it may behave unpredictably. Most likely
it&#39;ll just return the original matrix&#39;s capacity.</p>
          
          

          
          <div class="method-source-code" id="capacity-source">
            <pre>static VALUE nm_capacity(VALUE self) {
  VALUE cap;

  switch(NM_STYPE(self)) {
  case nm::YALE_STORE:
    cap = UINT2NUM(reinterpret_cast&lt;YALE_STORAGE*&gt;(NM_STORAGE_YALE(self)-&gt;src)-&gt;capacity);
    break;

  case nm::DENSE_STORE:
    cap = UINT2NUM(nm_storage_count_max_elements( NM_STORAGE_DENSE(self) ));
    break;

  case nm::LIST_STORE:
    cap = UINT2NUM(nm_list_storage_count_elements( NM_STORAGE_LIST(self) ));
    break;

  default:
    rb_raise(nm_eStorageTypeError, &quot;unrecognized stype in nm_capacity()&quot;);
  }

  return cap;
}</pre>
          </div><!-- capacity-source -->
          
        </div>

        

        
      </div><!-- capacity-method -->

    
      <div id="method-i-cast" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype, dtype, default) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype, dtype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(stype) &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast(options) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This is a user-friendly helper for calling <a
href="NMatrix.html#method-i-cast_full">cast_full</a>. The easiest way to
call this function is using an options hash, e.g.,</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">cast</span>(:<span class="ruby-identifier">stype</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">yale</span>, :<span class="ruby-identifier">dtype</span> =<span class="ruby-operator">&gt;</span> :<span class="ruby-identifier">int64</span>, :<span class="ruby-identifier">default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">false</span>)
</pre>

<p>For list and yale, :default sets the “default value” or “init” of the
matrix. List allows a bit more freedom since non-zeros are permitted. For
yale, unpredictable behavior may result if the value is not false, nil, or
some version of 0. Dense discards :default.</p>

<p>dtype and stype are inferred from the matrix upon which <a
href="NMatrix.html#method-i-cast">cast</a> is called – so you only really
need to provide one. You can actually call this function with no arguments,
in which case it functions like clone.</p>

<p>If your dtype is :object and you are converting from :dense to a sparse
type, it is recommended that you provide a :default, as 0 may behave
differently from its Float, Rational, or Complex equivalent. If no option
is given, Fixnum 0 will be used.</p>
          
          

          
          <div class="method-source-code" id="cast-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 141</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cast</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">Hash</span>))
    <span class="ruby-identifier">opts</span> = {
        <span class="ruby-value">:stype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>,
        <span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>,
        <span class="ruby-value">:default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>
    }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">params</span>[<span class="ruby-value">0</span>])

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast_full</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:stype</span>], <span class="ruby-identifier">opts</span>[<span class="ruby-value">:dtype</span>], <span class="ruby-identifier">opts</span>[<span class="ruby-value">:default</span>])
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-identifier">params</span> <span class="ruby-operator">&lt;&lt;</span> (<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">default_value</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">params</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast_full</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
  <span class="ruby-keyword">end</span>

<span class="ruby-keyword">end</span></pre>
          </div><!-- cast-source -->
          
        </div>

        

        
      </div><!-- cast-method -->

    
      <div id="method-i-cast_full" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cast_full(stype) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            cast_full(stype, dtype, sparse_basis) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Copy constructor for changing dtypes and stypes.</p>
          
          

          
          <div class="method-source-code" id="cast_full-source">
            <pre>VALUE nm_cast(VALUE self, VALUE new_stype_symbol, VALUE new_dtype_symbol, VALUE init) {
  nm::dtype_t new_dtype = nm_dtype_from_rbsymbol(new_dtype_symbol);
  nm::stype_t new_stype = nm_stype_from_rbsymbol(new_stype_symbol);

  CheckNMatrixType(self);
  NMATRIX *rhs;

  UnwrapNMatrix( self, rhs );

  void* init_ptr = ALLOCA_N(char, DTYPE_SIZES[new_dtype]);
  rubyval_to_cval(init, new_dtype, init_ptr);

  return Data_Wrap_Struct(CLASS_OF(self), nm_mark, nm_delete, nm_cast_with_ctype_args(rhs, new_stype, new_dtype, init_ptr));
}</pre>
          </div><!-- cast_full-source -->
          
        </div>

        

        
      </div><!-- cast_full-method -->

    
      <div id="method-i-col" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">col</span><span
            class="method-args">(column_number, get_by = :copy)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-column">column</a>
        </div>
        
      </div><!-- col-method -->

    
      <div id="method-i-cols" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cols &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of columns (the second dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="cols-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 178</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">cols</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- cols-source -->
          
        </div>

        

        
      </div><!-- cols-method -->

    
      <div id="method-i-column" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            column(column_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the column specified. Uses slicing by copy as default.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>column_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested column as a
column vector.</p>
</li></ul>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-identifier">m</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, [<span class="ruby-value">1</span>, <span class="ruby-value">4</span>, <span class="ruby-value">9</span>, <span class="ruby-value">14</span>], :<span class="ruby-identifier">int32</span>) <span class="ruby-comment"># =&gt;  1   4</span>
                                                <span class="ruby-value">9</span>  <span class="ruby-value">14</span>

<span class="ruby-identifier">m</span>.<span class="ruby-identifier">column</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt;   4</span>
                  <span class="ruby-value">14</span>
</pre>
          
          

          
          <div class="method-source-code" id="column-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 366</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">column</span>(<span class="ruby-identifier">column_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">1</span>, <span class="ruby-identifier">column_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- column-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-col">col</a>
        </div>
        

        
      </div><!-- column-method -->

    
      <div id="method-i-complex_conjugate" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate(new_stype) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the complex conjugate of this matrix. See also <a
href="NMatrix.html#method-i-complex_conjugate">#complex_conjugate</a>! for
an in-place operation (provided the dtype is already
<code>:complex64</code> or <code>:complex128</code>).</p>

<p>Doesn&#39;t work on list matrices, but you can optionally pass in the stype
you want to cast to if you&#39;re dealing with a list matrix.</p>
<ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>new_stype</code> -&gt; stype for the new matrix.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>If the original <a href="NMatrix.html">NMatrix</a> isn&#39;t complex, the
result is a <code>:complex128</code> <a href="NMatrix.html">NMatrix</a>.
Otherwise, it&#39;s the original dtype.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="complex_conjugate-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 226</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">complex_conjugate</span>(<span class="ruby-identifier">new_stype</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-identifier">new_stype</span>, <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-identifier">upcast</span>(<span class="ruby-identifier">dtype</span>, <span class="ruby-value">:complex64</span>)).<span class="ruby-identifier">complex_conjugate!</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- complex_conjugate-source -->
          
        </div>

        

        
      </div><!-- complex_conjugate-method -->

    
      <div id="method-i-complex_conjugate-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            complex_conjugate &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Transform the matrix (in-place) to its complex conjugate. Only works on
complex matrices.</p>

<p>FIXME: For non-complex matrices, someone needs to implement a non-in-place
complex conjugate (which doesn&#39;t use a bang). Bang should imply that no
copy is being made, even temporarily.</p>
          
          

          
          <div class="method-source-code" id="complex_conjugate-21-source">
            <pre>static VALUE nm_complex_conjugate_bang(VALUE self) {
  NMATRIX* m;
  void* elem;
  size_t size, p;

  UnwrapNMatrix(self, m);

  if (m-&gt;stype == nm::DENSE_STORE) {

    size = nm_storage_count_max_elements(NM_STORAGE(self));
    elem = NM_STORAGE_DENSE(self)-&gt;elements;

  } else if (m-&gt;stype == nm::YALE_STORE) {

    size = nm_yale_storage_get_size(NM_STORAGE_YALE(self));
    elem = NM_STORAGE_YALE(self)-&gt;a;

  } else {
    rb_raise(rb_eNotImpError, &quot;please cast to yale or dense (complex) first&quot;);
  }

  // Walk through and negate the imaginary component
  if (NM_DTYPE(self) == nm::COMPLEX64) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex64*&gt;(elem)[p].i;
    }

  } else if (NM_DTYPE(self) == nm::COMPLEX128) {

    for (p = 0; p &lt; size; ++p) {
      reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i = -reinterpret_cast&lt;nm::Complex128*&gt;(elem)[p].i;
    }

  } else {
    rb_raise(nm_eDataTypeError, &quot;can only calculate in-place complex conjugate on matrices of type :complex64 or :complex128&quot;);
  }

  return self;
}</pre>
          </div><!-- complex_conjugate-21-source -->
          
        </div>

        

        
      </div><!-- complex_conjugate-21-method -->

    
      <div id="method-i-conjugate_transpose" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            conjugate_transpose &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the conjugate transpose of a matrix. If your dtype is already
complex, this should only require one copy (for the transpose).</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The conjugate transpose of the matrix as a copy.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="conjugate_transpose-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 240</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">conjugate_transpose</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">transpose</span>.<span class="ruby-identifier">complex_conjugate!</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- conjugate_transpose-source -->
          
        </div>

        

        
      </div><!-- conjugate_transpose-method -->

    
      <div id="method-i-default_value" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            default_value &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the default value for the matrix. For dense, this is undefined and will
return Qnil. For list, it is user-defined. For yale, it&#39;s going to be
some variation on zero, but may be Qfalse or Qnil.</p>
          
          

          
          <div class="method-source-code" id="default_value-source">
            <pre>static VALUE nm_default_value(VALUE self) {
  switch(NM_STYPE(self)) {
  case nm::YALE_STORE:
    return nm_yale_default_value(self);
  case nm::LIST_STORE:
    return nm_list_default_value(self);
  case nm::DENSE_STORE:
  default:
    return Qnil;
  }
}</pre>
          </div><!-- default_value-source -->
          
        </div>

        

        
      </div><!-- default_value-method -->

    
      <div id="method-i-dense-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dense? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            list? &rarr; true or false
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            yale? &rarr; true or false
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shortcut functions for quickly determining a matrix&#39;s stype.</p>
          
          

          
          <div class="method-source-code" id="dense-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 47</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">dense?</span>; <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>; <span class="ruby-keyword">end</span></pre>
          </div><!-- dense-3F-source -->
          
        </div>

        

        
      </div><!-- dense-3F-method -->

    
      <div id="method-i-det" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            det &rarr; determinant
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculate the determinant by way of LU decomposition. This is accomplished
using clapack_getrf, and then by summing the diagonal elements. There is a
risk of underflow/overflow.</p>

<p>There are probably also more efficient ways to calculate the determinant.
This method requires making a copy of the matrix, since clapack_getrf
modifies its input.</p>

<p>For smaller matrices, you may be able to use <code>#det_exact</code>.</p>

<p>This function is guaranteed to return the same type of data in the matrix
upon which it is called. In other words, if you call it on a rational
matrix, you&#39;ll get a rational number back.</p>

<p>Integer matrices are converted to rational matrices for the purposes of
performing the calculation, as xGETRF can&#39;t work on integer matrices.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The determinant of the matrix. It&#39;s the same type as the matrix&#39;s
dtype.</p>
</li></ul>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>NotImplementedError</code> -&gt; Must be used in 2D matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="det-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 189</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">det</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;determinant can be calculated only for 2D matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

  <span class="ruby-comment"># Cast to a dtype for which getrf is implemented</span>
  <span class="ruby-identifier">new_dtype</span> = [<span class="ruby-value">:byte</span>,<span class="ruby-value">:int8</span>,<span class="ruby-value">:int16</span>,<span class="ruby-value">:int32</span>,<span class="ruby-value">:int64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">?</span> <span class="ruby-value">:rational128</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>
  <span class="ruby-identifier">copy</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:dense</span>, <span class="ruby-identifier">new_dtype</span>)

  <span class="ruby-comment"># Need to know the number of permutations. We&#39;ll add up the diagonals of</span>
  <span class="ruby-comment"># the factorized matrix.</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-identifier">copy</span>.<span class="ruby-identifier">getrf!</span>

  <span class="ruby-identifier">prod</span> = <span class="ruby-identifier">pivot</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">%</span> <span class="ruby-value">2</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-value">-1</span> <span class="ruby-operator">:</span> <span class="ruby-value">1</span> <span class="ruby-comment"># odd permutations =&gt; negative</span>
  [<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>],<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]].<span class="ruby-identifier">min</span>.<span class="ruby-identifier">times</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">prod</span> <span class="ruby-operator">*=</span> <span class="ruby-identifier">copy</span>[<span class="ruby-identifier">i</span>,<span class="ruby-identifier">i</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-comment"># Convert back to an integer if necessary</span>
  <span class="ruby-identifier">new_dtype</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">prod</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">prod</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- det-source -->
          
        </div>

        

        
      </div><!-- det-method -->

    
      <div id="method-i-det_exact" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">det_exact</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Calculate the exact determinant of a dense matrix.</p>

<p>Returns nil for dense matrices which are not square or number of dimensions
other than 2.</p>

<p>Note: Currently only implemented for 2x2 and 3x3 matrices.</p>
          
          

          
          <div class="method-source-code" id="det_exact-source">
            <pre>static VALUE nm_det_exact(VALUE self) {
  if (NM_STYPE(self) != nm::DENSE_STORE) rb_raise(nm_eStorageTypeError, &quot;can only calculate exact determinant for dense matrices&quot;);

  if (NM_DIM(self) != 2 || NM_SHAPE0(self) != NM_SHAPE1(self)) return Qnil;

  // Calculate the determinant and then assign it to the return value
  void* result = ALLOCA_N(char, DTYPE_SIZES[NM_DTYPE(self)]);
  nm_math_det_exact(NM_SHAPE0(self), NM_STORAGE_DENSE(self)-&gt;elements, NM_SHAPE0(self), NM_DTYPE(self), result);

  return rubyobj_from_cval(result, NM_DTYPE(self)).rval;
}</pre>
          </div><!-- det_exact-source -->
          
        </div>

        

        
      </div><!-- det_exact-method -->

    
      <div id="method-i-dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">dim</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-dimensions">dimensions</a>
        </div>
        
      </div><!-- dim-method -->

    
      <div id="method-i-dimensions" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dim &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the number of dimensions of a matrix.</p>

<p>In other words, if you set your matrix to be 3x4, the dim is 2. If the
matrix was initialized as 3x4x3, the dim is 3.</p>

<p>Use <a href="NMatrix.html#method-i-effective_dim">effective_dim</a> to get
the dimension of an <a href="NMatrix.html">NMatrix</a> which acts as a
vector (e.g., a column or row).</p>
          
          

          
          <div class="method-source-code" id="dimensions-source">
            <pre>static VALUE nm_dim(VALUE self) {
  return INT2FIX(NM_STORAGE(self)-&gt;dim);
}</pre>
          </div><!-- dimensions-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-dim">dim</a>
        </div>
        

        
      </div><!-- dimensions-method -->

    
      <div id="method-i-dot" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">dot</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Matrix multiply (dot product): against another matrix or a vector.</p>

<p>For elementwise, use * instead.</p>

<p>The two matrices must be of the same stype (for now). If dtype differs, an
upcast will occur.</p>
          
          

          
          <div class="method-source-code" id="dot-source">
            <pre>static VALUE nm_multiply(VALUE left_v, VALUE right_v) {
  NMATRIX *left, *right;

  UnwrapNMatrix( left_v, left );

  if (NM_RUBYVAL_IS_NUMERIC(right_v))
    return matrix_multiply_scalar(left, right_v);

  else if (TYPE(right_v) == T_ARRAY)
    rb_raise(rb_eNotImpError, &quot;please convert array to nx1 or 1xn NMatrix first&quot;);

  else { // both are matrices (probably)
    CheckNMatrixType(right_v);
    UnwrapNMatrix( right_v, right );

    if (left-&gt;storage-&gt;shape[1] != right-&gt;storage-&gt;shape[0])
      rb_raise(rb_eArgError, &quot;incompatible dimensions&quot;);

    if (left-&gt;stype != right-&gt;stype)
      rb_raise(rb_eNotImpError, &quot;matrices must have same stype&quot;);

    return matrix_multiply(left, right);

  }

  return Qnil;
}</pre>
          </div><!-- dot-source -->
          
        </div>

        

        
      </div><!-- dot-method -->

    
      <div id="method-i-dtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dtype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,
:int64, :float32, :float64, :complex64, :complex128, :rational32,
:rational64, :rational128, or :object (the last is a Ruby object).</p>
          
          

          
          <div class="method-source-code" id="dtype-source">
            <pre>static VALUE nm_dtype(VALUE self) {
  ID dtype = rb_intern(DTYPE_NAMES[NM_DTYPE(self)]);
  return ID2SYM(dtype);
}</pre>
          </div><!-- dtype-source -->
          
        </div>

        

        
      </div><!-- dtype-method -->

    
      <div id="method-i-each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Enumerate through the matrix. @see Enumerable#each</p>

<p>For dense, this actually calls a specialized each iterator (in C). For yale
and list, it relies upon <a
href="NMatrix.html#method-i-each_with_indices">each_with_indices</a> (which
is about as fast as reasonably possible for C code).</p>
          
          

          
          <div class="method-source-code" id="each-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 40</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each</span> <span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">__dense_each__</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">block_given?</span>
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">else</span> <span class="ruby-comment"># Handle case where no block is given</span>
    <span class="ruby-constant">Enumerator</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">yielder</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">params</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">yielder</span>.<span class="ruby-identifier">yield</span> <span class="ruby-identifier">params</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- each-source -->
          
        </div>

        

        
      </div><!-- each-method -->

    
      <div id="method-i-each_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">each_along_dim</span><span
            class="method-args">(dimen=0, get_by=:reference)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-each_rank">each_rank</a>
        </div>
        
      </div><!-- each_along_dim-method -->

    
      <div id="method-i-each_column" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_column { |column| block } &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each column, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>
          
          

          
          <div class="method-source-code" id="each_column-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 133</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_column</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_column</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">column</span>(<span class="ruby-identifier">j</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- each_column-source -->
          
        </div>

        

        
      </div><!-- each_column-method -->

    
      <div id="method-i-each_layer" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_layer -&gt; { |column| block } &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each layer, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>

<p>Note: If you have a 3-dimensional matrix, the first dimension contains
rows, the second contains columns, and the third contains layers.</p>
          
          

          
          <div class="method-source-code" id="each_layer-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 149</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_layer</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_layer</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">2</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">layer</span>(<span class="ruby-identifier">k</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- each_layer-source -->
          
        </div>

        

        
      </div><!-- each_layer-method -->

    
      <div id="method-i-each_ordered_stored_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_ordered_stored_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Very similar to <a
href="NMatrix.html#method-i-each_stored_with_indices">each_stored_with_indices</a>.
The key difference is that it enforces matrix ordering rather than storage
ordering, which only matters if your matrix is Yale.</p>
          
          

          
          <div class="method-source-code" id="each_ordered_stored_with_indices-source">
            <pre>static VALUE nm_each_ordered_stored_with_indices(VALUE nmatrix) {
  volatile VALUE nm = nmatrix;

  switch(NM_STYPE(nm)) {
  case nm::YALE_STORE:
    return nm_yale_each_ordered_stored_with_indices(nm);
  case nm::DENSE_STORE:
    return nm_dense_each_with_indices(nm);
  case nm::LIST_STORE:
    return nm_list_each_with_indices(nm, true);
  default:
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }
}</pre>
          </div><!-- each_ordered_stored_with_indices-source -->
          
        </div>

        

        
      </div><!-- each_ordered_stored_with_indices-method -->

    
      <div id="method-i-each_rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank() { |rank| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank(dimen) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            each_rank(dimen) { |rank| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Generic for @each_row, @each_col</p>

<p>Iterate through each rank by reference.</p>

<p>@param [Fixnum] dimen the rank being iterated over.</p>
          
          

          
          <div class="method-source-code" id="each_rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 106</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_rank</span>, <span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">idx</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">idx</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- each_rank-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-each_along_dim">each_along_dim</a>
        </div>
        

        
      </div><!-- each_rank-method -->

    
      <div id="method-i-each_row" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_row { |row| block } &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate through each row, referencing it as an <a
href="NMatrix.html">NMatrix</a> slice.</p>
          
          

          
          <div class="method-source-code" id="each_row-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 120</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_row</span>(<span class="ruby-identifier">get_by</span>=<span class="ruby-value">:reference</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_row</span>, <span class="ruby-identifier">get_by</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  (<span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]).<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">yield</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">row</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">get_by</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- each_row-source -->
          
        </div>

        

        
      </div><!-- each_row-method -->

    
      <div id="method-i-each_stored_with_index" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_stored_with_index &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Allow iteration across a vector NMatrix&#39;s stored values. See also
@each_stored_with_indices</p>
          
          

          
          <div class="method-source-code" id="each_stored_with_index-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 164</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_stored_with_index</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only works for dim 2 vectors&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:each_stored_with_index</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>,<span class="ruby-identifier">j</span>)
    <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">v</span>,<span class="ruby-identifier">i</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:each_stored_with_index</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- each_stored_with_index-source -->
          
        </div>

        

        
      </div><!-- each_stored_with_index-method -->

    
      <div id="method-i-each_stored_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_stored_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over the stored entries of any matrix. For dense and yale, this
iterates over non-zero entries; for list, this iterates over non-default
entries. Yields dim+1 values for each entry: i, j, …, and the entry itself.</p>
          
          

          
          <div class="method-source-code" id="each_stored_with_indices-source">
            <pre>static VALUE nm_each_stored_with_indices(VALUE nmatrix) {
  volatile VALUE nm = nmatrix;

  switch(NM_STYPE(nm)) {
  case nm::YALE_STORE:
    return nm_yale_each_stored_with_indices(nm);
  case nm::DENSE_STORE:
    return nm_dense_each_with_indices(nm);
  case nm::LIST_STORE:
    return nm_list_each_with_indices(nm, true);
  default:
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }
}</pre>
          </div><!-- each_stored_with_indices-source -->
          
        </div>

        

        
      </div><!-- each_stored_with_indices-method -->

    
      <div id="method-i-each_with_indices" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each_with_indices &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iterate over all entries of any matrix in standard storage order (as with
<a href="NMatrix.html#method-i-each">each</a>), and include the indices.</p>
          
          

          
          <div class="method-source-code" id="each_with_indices-source">
            <pre>static VALUE nm_each_with_indices(VALUE nmatrix) {
  volatile VALUE nm = nmatrix;

  switch(NM_STYPE(nm)) {
  case nm::YALE_STORE:
    return nm_yale_each_with_indices(nm);
  case nm::DENSE_STORE:
    return nm_dense_each_with_indices(nm);
  case nm::LIST_STORE:
    return nm_list_each_with_indices(nm, false);
  default:
    rb_raise(nm_eDataTypeError, &quot;Not a proper storage type&quot;);
  }
}</pre>
          </div><!-- each_with_indices-source -->
          
        </div>

        

        
      </div><!-- each_with_indices-method -->

    
      <div id="method-i-effective_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">effective_dim</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-effective_dimensions">effective_dimensions</a>
        </div>
        
      </div><!-- effective_dim-method -->

    
      <div id="method-i-effective_dimensions" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            effective_dim &rarr; Fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed
to be less than or equal to <a href="NMatrix.html#method-i-dim">dim</a>.</p>
          
          

          
          <div class="method-source-code" id="effective_dimensions-source">
            <pre>static VALUE nm_effective_dim(VALUE self) {
  return INT2FIX(effective_dim(NM_STORAGE(self)));
}</pre>
          </div><!-- effective_dimensions-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-effective_dim">effective_dim</a>
        </div>
        

        
      </div><!-- effective_dimensions-method -->

    
      <div id="method-i-factorize_lu" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            factorize_lu &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>LU factorization of a matrix.</p>

<p>FIXME: For some reason, getrf seems to require that the matrix be
transposed first – and then you have to transpose the FIXME: result again.
Ideally, this would be an in-place factorize instead, and would be called
nm_factorize_lu_bang.</p>
          
          

          
          <div class="method-source-code" id="factorize_lu-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 91</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">factorize_lu</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;only implemented for dense storage&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">NotImplementedError</span>, <span class="ruby-string">&quot;matrix is not 2-dimensional&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dimensions</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">transpose</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">t</span>, <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])
  <span class="ruby-identifier">t</span>.<span class="ruby-identifier">transpose</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- factorize_lu-source -->
          
        </div>

        

        
      </div><!-- factorize_lu-method -->

    
      <div id="method-i-flat_map" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">flat_map</span><span
            class="method-args">(&bl)</span>
          
        </div>
        

        <div class="method-description">
          
          <p>call-seq:</p>

<pre class="ruby"><span class="ruby-identifier">flat_map</span> <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Enumerator</span>
<span class="ruby-identifier">flat_map</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">elem</span><span class="ruby-operator">|</span> <span class="ruby-identifier">block</span> } <span class="ruby-operator">-</span><span class="ruby-operator">&gt;</span> <span class="ruby-constant">Array</span>
</pre>

<p>Maps using Enumerator (returns an <a href="Array.html">Array</a> or an
Enumerator)</p>
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-map">map</a>
        </div>
        
      </div><!-- flat_map-method -->

    
      <div id="method-i-gesdd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesdd &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESDD function. This uses a divide-and-conquer strategy. See also <a
href="NMatrix.html#method-i-gesvd">gesvd</a>.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesdd-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 136</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesdd</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">alloc_svd_result</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">lapack_gesvd</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:a</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">2</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">workspace_size</span>)
  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- gesdd-source -->
          
        </div>

        

        
      </div><!-- gesdd-method -->

    
      <div id="method-i-gesvd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd &rarr; [u, sigma, v_transpose]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            gesvd &rarr; [u, sigma, v_conjugate_transpose] # complex
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Compute the singular value decomposition of a matrix using LAPACK&#39;s
GESVD function.</p>

<p>Optionally accepts a <code>workspace_size</code> parameter, which will be
honored only if it is larger than what LAPACK requires.</p>
          
          

          
          <div class="method-source-code" id="gesvd-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 118</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">gesvd</span>(<span class="ruby-identifier">workspace_size</span>=<span class="ruby-value">1</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">alloc_svd_result</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">lapack_gesvd</span>(<span class="ruby-value">:a</span>, <span class="ruby-value">:a</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">result</span>[<span class="ruby-value">2</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">workspace_size</span>)
  <span class="ruby-identifier">result</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- gesvd-source -->
          
        </div>

        

        
      </div><!-- gesvd-method -->

    
      <div id="method-i-getrf-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            getrf! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>LU factorization of a general M-by-N matrix <code>A</code> using partial
pivoting with row interchanges. Only works in dense matrices.</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>The IPIV vector. The L and U matrices are stored in A.</p>
</li></ul>
</li><li>
<p><strong>Raises</strong> :</p>
<ul><li>
<p><code>StorageTypeError</code> -&gt; ATLAS functions only work on dense
matrices.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="getrf-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 77</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">getrf!</span>
  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">StorageTypeError</span>, <span class="ruby-string">&quot;ATLAS functions only work on dense matrices&quot;</span>) <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getrf</span>(<span class="ruby-value">:row</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>], <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>])
<span class="ruby-keyword">end</span></pre>
          </div><!-- getrf-21-source -->
          
        </div>

        

        
      </div><!-- getrf-21-method -->

    
      <div id="method-i-hermitian-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            hermitian? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix hermitian?</p>

<p>Definition: <a
href="http://en.wikipedia.org/wiki/Hermitian_matrix">en.wikipedia.org/wiki/Hermitian_matrix</a></p>

<p>For non-complex matrices, this function should return the same result as
symmetric?.</p>
          
          

          
          <div class="method-source-code" id="hermitian-3F-source">
            <pre>static VALUE nm_hermitian(VALUE self) {
  return is_symmetric(self, true);
}</pre>
          </div><!-- hermitian-3F-source -->
          
        </div>

        

        
      </div><!-- hermitian-3F-method -->

    
      <div id="method-i-initialize_copy" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">initialize_copy</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copy constructor for no change of dtype or stype (used for <a
href="NMatrix.html#method-i-initialize_copy">initialize_copy</a> hook).</p>
          
          

          
          <div class="method-source-code" id="initialize_copy-source">
            <pre>static VALUE nm_init_copy(VALUE copy, VALUE original) {
  NMATRIX *lhs, *rhs;

  CheckNMatrixType(original);

  if (copy == original) return copy;

  UnwrapNMatrix( original, rhs );
  UnwrapNMatrix( copy,     lhs );

  lhs-&gt;stype = rhs-&gt;stype;

  // Copy the storage
  CAST_TABLE(ttable);
  lhs-&gt;storage = ttable[lhs-&gt;stype][rhs-&gt;stype](rhs-&gt;storage, rhs-&gt;storage-&gt;dtype, NULL);

  return copy;
}</pre>
          </div><!-- initialize_copy-source -->
          
        </div>

        

        
      </div><!-- initialize_copy-method -->

    
      <div id="method-i-inject_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inject_along_dim</span><span
            class="method-args">(dimen=0, initial=nil, dtype=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-inject_rank">inject_rank</a>
        </div>
        
      </div><!-- inject_along_dim-method -->

    
      <div id="method-i-inject_rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank() &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial, dtype) &rarr; Enumerator
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank() { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            inject_rank(dimen, initial, dtype) { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reduces an <a href="NMatrix.html">NMatrix</a> using a supplied block over a
specified dimension. The block should behave the same way as for
Enumerable#reduce.</p>

<p>@param [Integer] dimen the dimension being reduced @param [Numeric] initial
the initial value for the reduction</p>

<pre>(i.e. the usual parameter to Enumerable#reduce).  Supply nil or do not
supply this argument to have it follow the usual Enumerable#reduce
behavior of using the first element as the initial value.</pre>

<p>@param [Symbol] dtype if non-nil/false, forces the accumulated result to
have this dtype @return [NMatrix] an <a href="NMatrix.html">NMatrix</a>
with the same number of dimensions as the</p>

<pre>input, but with the input dimension now having size 1.  Each element
is the result of the reduction at that position along the specified
dimension.</pre>
          
          

          
          <div class="method-source-code" id="inject_rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 206</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>, <span class="ruby-identifier">initial</span>=<span class="ruby-keyword">nil</span>, <span class="ruby-identifier">dtype</span>=<span class="ruby-keyword">nil</span>)

  <span class="ruby-identifier">raise</span>(<span class="ruby-constant">RangeError</span>, <span class="ruby-node">&quot;requested dimension (#{dimen}) does not exist (shape: #{shape})&quot;</span>) <span class="ruby-keyword">if</span> <span class="ruby-identifier">dimen</span> <span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>

  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:inject_rank</span>, <span class="ruby-identifier">dimen</span>, <span class="ruby-identifier">initial</span>, <span class="ruby-identifier">dtype</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>

  <span class="ruby-identifier">new_shape</span> = <span class="ruby-identifier">shape</span>
  <span class="ruby-identifier">new_shape</span>[<span class="ruby-identifier">dimen</span>] = <span class="ruby-value">1</span>

  <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">false</span>

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">initial</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">acc</span> = <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">new_shape</span>, <span class="ruby-identifier">initial</span>, <span class="ruby-value">:dtype</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">dtype</span> <span class="ruby-operator">||</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">acc</span> = (<span class="ruby-identifier">sub_mat</span>.<span class="ruby-identifier">is_a?</span>(<span class="ruby-constant">NMatrix</span>) <span class="ruby-keyword">and</span> <span class="ruby-operator">!</span><span class="ruby-identifier">dtype</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">dtype</span> <span class="ruby-operator">!=</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">sub_mat</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-identifier">dtype</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
      <span class="ruby-keyword">break</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">true</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">each_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">first_as_acc</span>
      <span class="ruby-identifier">first_as_acc</span> = <span class="ruby-keyword">false</span>
      <span class="ruby-keyword">next</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">acc</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">acc</span>, <span class="ruby-identifier">sub_mat</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">acc</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- inject_rank-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-reduce_along_dim">reduce_along_dim</a>, <a href="NMatrix.html#method-i-inject_along_dim">inject_along_dim</a>
        </div>
        

        
      </div><!-- inject_rank-method -->

    
      <div id="method-i-integer_dtype-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            integer_dtype?() &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Checks if dtype is an integer type</p>
          
          

          
          <div class="method-source-code" id="integer_dtype-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 228</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">integer_dtype?</span>
  [<span class="ruby-value">:byte</span>, <span class="ruby-value">:int8</span>, <span class="ruby-value">:int16</span>, <span class="ruby-value">:int32</span>, <span class="ruby-value">:int64</span>].<span class="ruby-identifier">include?</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- integer_dtype-3F-source -->
          
        </div>

        

        
      </div><!-- integer_dtype-3F-method -->

    
      <div id="method-i-inverse" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">inverse</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-invert">invert</a>
        </div>
        
      </div><!-- inverse-method -->

    
      <div id="method-i-invert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            invert &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Make a copy of the matrix, then invert it (requires LAPACK).</p>
<ul><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A dense <a href="NMatrix.html">NMatrix</a>.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="invert-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 60</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:dense</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>).<span class="ruby-identifier">invert!</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- invert-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-inverse">inverse</a>
        </div>
        

        
      </div><!-- invert-method -->

    
      <div id="method-i-invert-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            invert! &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Use LAPACK to calculate the inverse of the matrix (in-place). Only works on
dense matrices.</p>

<p>Note: If you don&#39;t have LAPACK, e.g., on a Mac, this may not work yet.</p>
          
          

          
          <div class="method-source-code" id="invert-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 41</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">invert!</span>
  <span class="ruby-comment"># Get the pivot array; factor the matrix</span>
  <span class="ruby-identifier">pivot</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">getrf!</span>

  <span class="ruby-comment"># Now calculate the inverse using the pivot array</span>
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">clapack_getri</span>(<span class="ruby-value">:row</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-keyword">self</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">pivot</span>)

  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- invert-21-source -->
          
        </div>

        

        
      </div><!-- invert-21-method -->

    
      <div id="method-i-is_ref-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">is_ref?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Check to determine whether matrix is a reference to another matrix.</p>
          
          

          
          <div class="method-source-code" id="is_ref-3F-source">
            <pre>static VALUE nm_is_ref(VALUE self) {
  if (NM_SRC(self) == NM_STORAGE(self)) return Qfalse;
  else                                  return Qtrue;
}</pre>
          </div><!-- is_ref-3F-source -->
          
        </div>

        

        
      </div><!-- is_ref-3F-method -->

    
      <div id="method-i-laswp" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            laswp(ary) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Permute the columns of a dense matrix using LASWP according to the order
given in an <a href="Array.html">Array</a> <code>ary</code>. Not yet
implemented for yale or list.</p>
          
          

          
          <div class="method-source-code" id="laswp-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">laswp</span>(<span class="ruby-identifier">ary</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>.<span class="ruby-identifier">laswp!</span>(<span class="ruby-identifier">ary</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- laswp-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-permute_columns">permute_columns</a>
        </div>
        

        
      </div><!-- laswp-method -->

    
      <div id="method-i-laswp-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            laswp!(ary) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>In-place permute the columns of a dense matrix using LASWP according to the
order given in an <a href="Array.html">Array</a> <code>ary</code>. Not yet
implemented for yale or list.</p>
          
          

          
          <div class="method-source-code" id="laswp-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 148</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">laswp!</span>(<span class="ruby-identifier">ary</span>)
  <span class="ruby-constant">NMatrix</span><span class="ruby-operator">::</span><span class="ruby-constant">LAPACK</span><span class="ruby-operator">::</span><span class="ruby-identifier">laswp</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">ary</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- laswp-21-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-permute_columns-21">permute_columns!</a>
        </div>
        

        
      </div><!-- laswp-21-method -->

    
      <div id="method-i-layer" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            layer(layer_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            row(layer_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>layer_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested layer as a
layer vector.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="layer-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 398</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">layer</span>(<span class="ruby-identifier">layer_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">2</span>, <span class="ruby-identifier">layer_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- layer-source -->
          
        </div>

        

        
      </div><!-- layer-method -->

    
      <div id="method-i-list-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">list?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="list-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 49</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">list?</span>;  <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:list</span>;  <span class="ruby-keyword">end</span></pre>
          </div><!-- list-3F-source -->
          
        </div>

        

        
      </div><!-- list-3F-method -->

    
      <div id="method-i-map" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns an <a href="NMatrix.html">NMatrix</a> if a block is given. For an
<a href="Array.html">Array</a>, use <a
href="NMatrix.html#method-i-flat_map">flat_map</a></p>
          
          

          
          <div class="method-source-code" id="map-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 69</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">map</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>)
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:map</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-identifier">cp</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dup</span>
  <span class="ruby-identifier">cp</span>.<span class="ruby-identifier">map!</span> <span class="ruby-operator">&amp;</span><span class="ruby-identifier">bl</span>
  <span class="ruby-identifier">cp</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- map-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-flat_map">flat_map</a>
        </div>
        

        
      </div><!-- map-method -->

    
      <div id="method-i-map-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            map! &rarr; Enumerator
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            map! { |elem| block } &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Maps in place. @see <a href="NMatrix.html#method-i-map">map</a></p>
          
          

          
          <div class="method-source-code" id="map-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/enumerate.rb, line 84</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">map!</span>
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">enum_for</span>(<span class="ruby-value">:map!</span>) <span class="ruby-keyword">unless</span> <span class="ruby-identifier">block_given?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">e</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">i</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">i</span>] = (<span class="ruby-keyword">yield</span> <span class="ruby-identifier">e</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- map-21-source -->
          
        </div>

        

        
      </div><!-- map-21-method -->

    
      <div id="method-i-max" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            max(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the maximum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="max-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 329</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">max</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">max</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">max</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">NMatrix</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">max</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">max</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">+</span> ((<span class="ruby-identifier">max</span>)<span class="ruby-operator">*</span><span class="ruby-value">0.0</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">max</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)) <span class="ruby-operator">*</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">max</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">sub_mat</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">max</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- max-source -->
          
        </div>

        

        
      </div><!-- max-method -->

    
      <div id="method-i-mean" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            mean() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            mean(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the mean along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="mean-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">mean</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>, <span class="ruby-identifier">reduce_dtype</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">mean</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">mean</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">/</span><span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- mean-source -->
          
        </div>

        

        
      </div><!-- mean-method -->

    
      <div id="method-i-min" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            min() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            min(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the minimum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="min-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 310</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">min</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">min</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">min</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">NMatrix</span> <span class="ruby-keyword">then</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">*</span> (<span class="ruby-identifier">min</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">+</span> ((<span class="ruby-identifier">min</span>)<span class="ruby-operator">*</span><span class="ruby-value">0.0</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">min</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">sub_mat</span>).<span class="ruby-identifier">cast</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">stype</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>)) <span class="ruby-operator">*</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">min</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">sub_mat</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">min</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sub_mat</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- min-source -->
          
        </div>

        

        
      </div><!-- min-method -->

    
      <div id="method-i-nvector-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            nvector? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shortcut function for determining whether the effective dimension is less
than the dimension. Useful when we take slices of n-dimensional matrices
where n &gt; 2.</p>
          
          

          
          <div class="method-source-code" id="nvector-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 283</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">nvector?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&lt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- nvector-3F-source -->
          
        </div>

        

        
      </div><!-- nvector-3F-method -->

    
      <div id="method-i-offset" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            offset &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the offset (slice position) of a matrix. Typically all zeros, unless
you have a reference slice.</p>
          
          

          
          <div class="method-source-code" id="offset-source">
            <pre>static VALUE nm_offset(VALUE self) {
  STORAGE* s   = NM_STORAGE(self);

  // Copy elements into a VALUE array and then use those to create a Ruby array with rb_ary_new4.
  VALUE* offset = ALLOCA_N(VALUE, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    offset[index] = INT2FIX(s-&gt;offset[index]);

  return rb_ary_new4(s-&gt;dim, offset);
}</pre>
          </div><!-- offset-source -->
          
        </div>

        

        
      </div><!-- offset-method -->

    
      <div id="method-i-permute_columns" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">permute_columns</span><span
            class="method-args">(ary)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-laswp">laswp</a>
        </div>
        
      </div><!-- permute_columns-method -->

    
      <div id="method-i-permute_columns-21" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">permute_columns!</span><span
            class="method-args">(ary)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-laswp-21">laswp!</a>
        </div>
        
      </div><!-- permute_columns-21-method -->

    
      <div id="method-i-rank" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rank(dimension, row_or_column_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            rank(dimension, row_or_column_number, :reference) &rarr; NMatrix reference slice
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the rank (e.g., row, column, or layer) specified, using slicing by
copy as default.</p>

<p>See @row (dimension = 0), @column (dimension = 1)</p>
          
          

          
          <div class="method-source-code" id="rank-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 335</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rank</span>(<span class="ruby-identifier">shape_idx</span>, <span class="ruby-identifier">rank_idx</span>, <span class="ruby-identifier">meth</span> = <span class="ruby-value">:copy</span>)

  <span class="ruby-identifier">params</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span>)
  <span class="ruby-identifier">params</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">d</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">params</span>[<span class="ruby-identifier">d</span>] = <span class="ruby-identifier">d</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">shape_idx</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">rank_idx</span> <span class="ruby-operator">:</span> <span class="ruby-value">0</span><span class="ruby-operator">...</span><span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">d</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">meth</span> <span class="ruby-operator">==</span> <span class="ruby-value">:reference</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>] <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">params</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- rank-source -->
          
        </div>

        

        
      </div><!-- rank-method -->

    
      <div id="method-i-reduce_along_dim" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">reduce_along_dim</span><span
            class="method-args">(dimen=0, initial=nil, dtype=nil)</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-inject_rank">inject_rank</a>
        </div>
        
      </div><!-- reduce_along_dim-method -->

    
      <div id="method-i-row" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            row(row_number) &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            row(row_number, get_by) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <ul><li>
<p><strong>Arguments</strong> :</p>
<ul><li>
<p><code>row_number</code> -&gt; Integer.</p>
</li><li>
<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or
<code>:reference</code>.</p>
</li></ul>
</li><li>
<p><strong>Returns</strong> :</p>
<ul><li>
<p>A <a href="NMatrix.html">NMatrix</a> representing the requested row as a
row vector.</p>
</li></ul>
</li></ul>
          
          

          
          <div class="method-source-code" id="row-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 383</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">row</span>(<span class="ruby-identifier">row_number</span>, <span class="ruby-identifier">get_by</span> = <span class="ruby-value">:copy</span>)
  <span class="ruby-identifier">rank</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">row_number</span>, <span class="ruby-identifier">get_by</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- row-source -->
          
        </div>

        

        
      </div><!-- row-method -->

    
      <div id="method-i-rows" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            rows &rarr; Integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>This shortcut use <a href="NMatrix.html#method-i-shape">shape</a> to return
the number of rows (the first dimension) of the matrix.</p>
          
          

          
          <div class="method-source-code" id="rows-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 167</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">rows</span>
  <span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>]
<span class="ruby-keyword">end</span></pre>
          </div><!-- rows-source -->
          
        </div>

        

        
      </div><!-- rows-method -->

    
      <div id="method-i-shape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shape &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the shape (dimensions) of a matrix.</p>
          
          

          
          <div class="method-source-code" id="shape-source">
            <pre>static VALUE nm_shape(VALUE self) {
  STORAGE* s   = NM_STORAGE(self);

  // Copy elements into a VALUE array and then use those to create a Ruby array with rb_ary_new4.
  VALUE* shape = ALLOCA_N(VALUE, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    shape[index] = INT2FIX(s-&gt;shape[index]);

  return rb_ary_new4(s-&gt;dim, shape);
}</pre>
          </div><!-- shape-source -->
          
        </div>

        

        
      </div><!-- shape-method -->

    
      <div id="method-i-shuffle" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle(rng) &rarr; ...
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Re-arranges the contents of an <a href="NVector.html">NVector</a>.</p>

<p>TODO: Write more efficient version for Yale, list. TODO: Generalize for
more dimensions.</p>
          
          

          
          <div class="method-source-code" id="shuffle-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 431</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">shuffle</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:shuffle!</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">t</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">clone</span>
  <span class="ruby-identifier">t</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- shuffle-source -->
          
        </div>

        

        
      </div><!-- shuffle-method -->

    
      <div id="method-i-shuffle-21" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle! &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            shuffle!(random: rng) &rarr; ...
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Re-arranges the contents of an <a href="NVector.html">NVector</a>.</p>

<p>TODO: Write more efficient version for Yale, list. TODO: Generalize for
more dimensions.</p>
          
          

          
          <div class="method-source-code" id="shuffle-21-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 413</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">method_missing</span>(<span class="ruby-value">:shuffle!</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span>) <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_a</span>
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">shuffle!</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">ary</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">idx</span><span class="ruby-operator">|</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">idx</span>] = <span class="ruby-identifier">v</span> }
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- shuffle-21-source -->
          
        </div>

        

        
      </div><!-- shuffle-21-method -->

    
      <div id="method-i-size" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            size &rarr; Fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Returns the total size of the <a href="NMatrix.html">NMatrix</a> based on
its shape.</p>
          
          

          
          <div class="method-source-code" id="size-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 267</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>
  <span class="ruby-constant">NMatrix</span>.<span class="ruby-identifier">size</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>)
<span class="ruby-keyword">end</span></pre>
          </div><!-- size-source -->
          
        </div>

        

        
      </div><!-- size-method -->

    
      <div id="method-i-slice" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            slice &rarr; ...
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Access the contents of an <a href="NMatrix.html">NMatrix</a> at given
coordinates, using copying.</p>

<pre class="ruby"><span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">3</span>,<span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; 5.0</span>
<span class="ruby-identifier">n</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>,<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>) <span class="ruby-comment">#=&gt; matrix [2,2]</span>
</pre>
          
          

          
          <div class="method-source-code" id="slice-source">
            <pre>static VALUE nm_mget(int argc, VALUE* argv, VALUE self) {
  static void* (*ttable[nm::NUM_STYPES])(const STORAGE*, SLICE*) = {
    nm_dense_storage_get,
    nm_list_storage_get,
    nm_yale_storage_get
  };
  return nm_xslice(argc, argv, ttable[NM_STYPE(self)], nm_delete, self);
}</pre>
          </div><!-- slice-source -->
          
        </div>

        

        
      </div><!-- slice-method -->

    
      <div id="method-i-std" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            std() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            std(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sample standard deviation along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="std-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 374</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">std</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">variance</span>(<span class="ruby-identifier">dimen</span>).<span class="ruby-identifier">map!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-constant">Math</span>.<span class="ruby-identifier">sqrt</span>(<span class="ruby-identifier">e</span>) }
<span class="ruby-keyword">end</span></pre>
          </div><!-- std-source -->
          
        </div>

        

        
      </div><!-- std-method -->

    
      <div id="method-i-stype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            stype &rarr; Symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.</p>
          
          

          
          <div class="method-source-code" id="stype-source">
            <pre>static VALUE nm_stype(VALUE self) {
  ID stype = rb_intern(STYPE_NAMES[NM_STYPE(self)]);
  return ID2SYM(stype);
}</pre>
          </div><!-- stype-source -->
          
        </div>

        

        
      </div><!-- stype-method -->

    
      <div id="method-i-sum" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            sum() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            sum(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sum along the specified dimension.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="sum-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 294</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">sum</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">sum</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">sum</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">sub_mat</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- sum-source -->
          
        </div>

        

        
      </div><!-- sum-method -->

    
      <div id="method-i-supershape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            supershape &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the shape of a slice&#39;s parent.</p>
          
          

          
          <div class="method-source-code" id="supershape-source">
            <pre>static VALUE nm_supershape(VALUE self) {

  STORAGE* s   = NM_STORAGE(self);
  if (s-&gt;src == s) return nm_shape(self); // easy case (not a slice)
  else s = s-&gt;src;

  VALUE* shape = ALLOCA_N(VALUE, s-&gt;dim);
  for (size_t index = 0; index &lt; s-&gt;dim; ++index)
    shape[index] = INT2FIX(s-&gt;shape[index]);

  return rb_ary_new4(s-&gt;dim, shape);
}</pre>
          </div><!-- supershape-source -->
          
        </div>

        

        
      </div><!-- supershape-method -->

    
      <div id="method-i-symmetric-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            symmetric? &rarr; Boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Is this matrix symmetric?</p>
          
          

          
          <div class="method-source-code" id="symmetric-3F-source">
            <pre>static VALUE nm_symmetric(VALUE self) {
  return is_symmetric(self, false);
}</pre>
          </div><!-- symmetric-3F-source -->
          
        </div>

        

        
      </div><!-- symmetric-3F-method -->

    
      <div id="method-i-to_a" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_a &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an <a href="NMatrix.html">NMatrix</a> to an array of arrays, or an
<a href="NMatrix.html">NMatrix</a> of effective dimension 1 to an array.</p>

<p>Does not yet work for dimensions &gt; 2</p>
          
          

          
          <div class="method-source-code" id="to_a-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 305</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_a</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">2</span>

    <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_flat_a</span> <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">shape</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">1</span>

    <span class="ruby-identifier">ary</span> = []
    <span class="ruby-keyword">begin</span>
      <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each_row</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">row</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">ary</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">row</span>.<span class="ruby-identifier">to_flat_a</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-comment">#rescue NotImplementedError # Oops. Try copying instead</span>
    <span class="ruby-comment">#  self.each_row(:copy) do |row|</span>
    <span class="ruby-comment">#    ary &lt;&lt; row.to_a.flatten</span>
    <span class="ruby-comment">#  end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">ary</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">to_a_rec</span>(<span class="ruby-value">0</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- to_a-source -->
          
        </div>

        

        
      </div><!-- to_a-method -->

    
      <div id="method-i-to_f" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_f &rarr; Float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an nmatrix with a single element (but any number of dimensions)</p>

<pre>to a float.</pre>

<p>Raises an IndexError if the matrix does not have just a single element.</p>
          
          

          
          <div class="method-source-code" id="to_f-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_f</span>
  <span class="ruby-identifier">raise</span> <span class="ruby-constant">IndexError</span>, <span class="ruby-string">&#39;to_f only valid for matrices with a single element&#39;</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">shape</span>.<span class="ruby-identifier">all?</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">e</span><span class="ruby-operator">|</span> <span class="ruby-identifier">e</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span> }
  <span class="ruby-keyword">self</span>[<span class="ruby-operator">*</span><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shape</span>.<span class="ruby-identifier">size</span>, <span class="ruby-value">0</span>)]
<span class="ruby-keyword">end</span></pre>
          </div><!-- to_f-source -->
          
        </div>

        

        
      </div><!-- to_f-method -->

    
      <div id="method-i-to_flat_a" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_flat_a</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-to_flat_array">to_flat_array</a>
        </div>
        
      </div><!-- to_flat_a-method -->

    
      <div id="method-i-to_flat_array" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_flat_array &rarr; Array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            to_flat_a &rarr; Array
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Converts an <a href="NMatrix.html">NMatrix</a> to a one-dimensional Ruby <a
href="Array.html">Array</a>.</p>
          
          

          
          <div class="method-source-code" id="to_flat_array-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_flat_array</span>
  <span class="ruby-identifier">ary</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span>)
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">each</span>.<span class="ruby-identifier">with_index</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">v</span>,<span class="ruby-identifier">i</span><span class="ruby-operator">|</span> <span class="ruby-identifier">ary</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">v</span> }
  <span class="ruby-identifier">ary</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- to_flat_array-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-to_flat_a">to_flat_a</a>
        </div>
        

        
      </div><!-- to_flat_array-method -->

    
      <div id="method-i-to_h" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">to_h</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="NMatrix.html#method-i-to_hash">to_hash</a>
        </div>
        
      </div><!-- to_h-method -->

    
      <div id="method-i-to_hash" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            to_hash &rarr; Hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Create a Ruby Hash from an <a href="NMatrix.html">NMatrix</a>.</p>
          
          

          
          <div class="method-source-code" id="to_hash-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 188</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_hash</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:yale</span>
    <span class="ruby-identifier">h</span> = {}
    <span class="ruby-identifier">each_stored_with_indices</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">val</span>,<span class="ruby-identifier">i</span>,<span class="ruby-identifier">j</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">next</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">val</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span> <span class="ruby-comment"># Don&#39;t bother storing the diagonal zero values -- only non-zeros.</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">i</span>)
        <span class="ruby-identifier">h</span>[<span class="ruby-identifier">i</span>][<span class="ruby-identifier">j</span>] = <span class="ruby-identifier">val</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-identifier">h</span>[<span class="ruby-identifier">i</span>] = {<span class="ruby-identifier">j</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">val</span>}
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
    <span class="ruby-identifier">h</span>
  <span class="ruby-keyword">else</span> <span class="ruby-comment"># dense and list should use a C internal function.</span>
    <span class="ruby-comment"># FIXME: Write a C internal to_h function.</span>
    <span class="ruby-identifier">m</span> = <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:dense</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">cast</span>(<span class="ruby-value">:list</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">dtype</span>) <span class="ruby-operator">:</span> <span class="ruby-keyword">self</span>
    <span class="ruby-identifier">m</span>.<span class="ruby-identifier">__list_to_hash__</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- to_hash-source -->
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="NMatrix.html#method-i-to_h">to_h</a>
        </div>
        

        
      </div><!-- to_hash-method -->

    
      <div id="method-i-transpose" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">transpose</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Copy constructor for transposing.</p>
          
          

          
          <div class="method-source-code" id="transpose-source">
            <pre>static VALUE nm_init_transposed(VALUE self) {
  static STORAGE* (*storage_copy_transposed[nm::NUM_STYPES])(const STORAGE* rhs_base) = {
    nm_dense_storage_copy_transposed,
    nm_list_storage_copy_transposed,
    nm_yale_storage_copy_transposed
  };

  NMATRIX* lhs = nm_create( NM_STYPE(self),
                            storage_copy_transposed[NM_STYPE(self)]( NM_STORAGE(self) )
                          );

  return Data_Wrap_Struct(CLASS_OF(self), nm_mark, nm_delete, lhs);
}</pre>
          </div><!-- transpose-source -->
          
        </div>

        

        
      </div><!-- transpose-method -->

    
      <div id="method-i-variance" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            variance() &rarr; NMatrix
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            variance(dimen) &rarr; NMatrix
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Calculates the sample variance along the specified dimension.</p>

<p>This will force integer types to float64 dtype.</p>

<p>@see <a href="NMatrix.html#method-i-inject_rank">inject_rank</a></p>
          
          

          
          <div class="method-source-code" id="variance-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/math.rb, line 351</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">variance</span>(<span class="ruby-identifier">dimen</span>=<span class="ruby-value">0</span>)
  <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">integer_dtype?</span> <span class="ruby-keyword">then</span>
    <span class="ruby-identifier">reduce_dtype</span> = <span class="ruby-value">:float64</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">m</span> = <span class="ruby-identifier">mean</span>(<span class="ruby-identifier">dimen</span>)
  <span class="ruby-identifier">inject_rank</span>(<span class="ruby-identifier">dimen</span>, <span class="ruby-value">0.0</span>, <span class="ruby-identifier">reduce_dtype</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">var</span>, <span class="ruby-identifier">sub_mat</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">var</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">m</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">sub_mat</span>)<span class="ruby-operator">*</span>(<span class="ruby-identifier">m</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">sub_mat</span>)<span class="ruby-operator">/</span>(<span class="ruby-identifier">shape</span>[<span class="ruby-identifier">dimen</span>]<span class="ruby-operator">-</span><span class="ruby-value">1</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- variance-source -->
          
        </div>

        

        
      </div><!-- variance-method -->

    
      <div id="method-i-vector-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            vector? &rarr; true or false
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Shortcut function for determining whether the effective dimension is 1. See
also <a href="NMatrix.html#method-i-nvector-3F">nvector?</a></p>
          
          

          
          <div class="method-source-code" id="vector-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/nmatrix.rb, line 293</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">vector?</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">effective_dim</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- vector-3F-source -->
          
        </div>

        

        
      </div><!-- vector-3F-method -->

    
      <div id="method-i-write" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">write</span><span
            class="method-args">(*args)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Binary file writer for <a href="NMatrix.html">NMatrix</a> standard format.
file should be a path, which we aren&#39;t going to check very carefully
(in other words, this function should generally be called from a Ruby
helper method). Function also takes a symmetry argument, which allows us to
specify that we only want to save the upper triangular portion of the
matrix (or if the matrix is a lower triangular matrix, only the lower
triangular portion). nil means regular storage.</p>
          
          

          
          <div class="method-source-code" id="write-source">
            <pre>static VALUE nm_write(int argc, VALUE* argv, VALUE self) {
  using std::ofstream;

  if (argc &lt; 1 || argc &gt; 2) {
    rb_raise(rb_eArgError, &quot;Expected one or two arguments&quot;);
  }
  VALUE file = argv[0],
        symm = argc == 1 ? Qnil : argv[1];

  NMATRIX* nmatrix;
  UnwrapNMatrix( self, nmatrix );

  nm::symm_t symm_ = interpret_symm(symm);

  if (nmatrix-&gt;storage-&gt;dtype == nm::RUBYOBJ) {
    rb_raise(rb_eNotImpError, &quot;Ruby Object writing is not implemented yet&quot;);
  }

  // Get the dtype, stype, itype, and symm and ensure they&#39;re the correct number of bytes.
  uint8_t st = static_cast&lt;uint8_t&gt;(nmatrix-&gt;stype),
          dt = static_cast&lt;uint8_t&gt;(nmatrix-&gt;storage-&gt;dtype),
          sm = static_cast&lt;uint8_t&gt;(symm_);
  uint16_t dim = nmatrix-&gt;storage-&gt;dim;

  //FIXME: Cast the matrix to the smallest possible index type. Write that in the place of IType.

  // Check arguments before starting to write.
  if (nmatrix-&gt;stype == nm::LIST_STORE) rb_raise(nm_eStorageTypeError, &quot;cannot save list matrix; cast to yale or dense first&quot;);
  if (symm_ != nm::NONSYMM) {
    if (dim != 2) rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-2D matrix&quot;);
    if (nmatrix-&gt;storage-&gt;shape[0] != nmatrix-&gt;storage-&gt;shape[1])
      rb_raise(rb_eArgError, &quot;symmetry/triangularity not defined for a non-square matrix&quot;);
    if (symm_ == nm::HERM &amp;&amp;
          dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX64) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::COMPLEX128) &amp;&amp; dt != static_cast&lt;uint8_t&gt;(nm::RUBYOBJ))
      rb_raise(rb_eArgError, &quot;cannot save a non-complex matrix as hermitian&quot;);
  }

  ofstream f(RSTRING_PTR(file), std::ios::out | std::ios::binary);

  // Get the NMatrix version information.
  uint16_t major, minor, release, null16 = 0;
  get_version_info(major, minor, release);

  // WRITE FIRST 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;major),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;minor),   sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;release), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16),  sizeof(uint16_t));

  uint8_t ZERO = 0;
  // WRITE SECOND 64-BIT BLOCK
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dt), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;st), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;ZERO),sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;sm), sizeof(uint8_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;null16), sizeof(uint16_t));
  f.write(reinterpret_cast&lt;const char*&gt;(&amp;dim), sizeof(uint16_t));

  // Write shape (in 64-bit blocks)
  write_padded_shape(f, nmatrix-&gt;storage-&gt;dim, nmatrix-&gt;storage-&gt;shape);

  if (nmatrix-&gt;stype == nm::DENSE_STORE) {
    write_padded_dense_elements(f, reinterpret_cast&lt;DENSE_STORAGE*&gt;(nmatrix-&gt;storage), symm_, nmatrix-&gt;storage-&gt;dtype);
  } else if (nmatrix-&gt;stype == nm::YALE_STORE) {
    YALE_STORAGE* s = reinterpret_cast&lt;YALE_STORAGE*&gt;(nmatrix-&gt;storage);
    uint32_t ndnz   = s-&gt;ndnz,
             length = nm_yale_storage_get_size(s);
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;ndnz),   sizeof(uint32_t));
    f.write(reinterpret_cast&lt;const char*&gt;(&amp;length), sizeof(uint32_t));

    write_padded_yale_elements(f, s, length, symm_, s-&gt;dtype);
  }

  f.close();

  return Qtrue;
}</pre>
          </div><!-- write-source -->
          
        </div>

        

        
      </div><!-- write-method -->

    
      <div id="method-i-yale-3F" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">yale?</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="yale-3F-source">
            <pre><span class="ruby-comment"># File lib/nmatrix/shortcuts.rb, line 48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">yale?</span>;  <span class="ruby-keyword">return</span> <span class="ruby-identifier">stype</span> <span class="ruby-operator">==</span> <span class="ruby-value">:yale</span>;  <span class="ruby-keyword">end</span></pre>
          </div><!-- yale-3F-source -->
          
        </div>

        

        
      </div><!-- yale-3F-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.1.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

