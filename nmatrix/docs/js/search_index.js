var search_data = {"index":{"searchIndex":["array","datatypeerror","n","n","blas","io","market","matlab","mat5reader","compressed","element","elementdataioerror","header","matrixdata","rawelement","tag","matreader","lapack","yalefunctions","nvector","nvector","object","rspec","matchers","builtin","bewithin","storagetypeerror","unknown","==()","==()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","[]=()","abs()","abs()","abs_dtype()","abs_dtype()","absolute_sum()","alloc_svd_result()","alloc_svd_result()","asum()","asum()","bindgen()","bindgen()","bindgen()","binned_sorted_indices()","capacity()","capacity()","cast()","cast()","cast_full()","cast_full()","cindgen()","cindgen()","cindgen()","clapack_gesv()","clapack_posv()","col()","col()","cols()","cols()","column()","column()","complex_conjugate()","complex_conjugate()","complex_conjugate!()","complex_conjugate!()","complex_merge()","compressed()","conjugate_transpose()","conjugate_transpose()","content()","default_value()","default_value()","dense?()","dense?()","det()","det()","det_exact()","det_exact()","diag()","diag()","diagonal()","diagonal()","diagonals()","diagonals()","dim()","dim()","dim()","dimensions()","dimensions()","dot()","dot()","dtype()","dtype()","each()","each()","each()","each_along_dim()","each_along_dim()","each_column()","each_column()","each_layer()","each_layer()","each_ordered_stored_with_indices()","each_ordered_stored_with_indices()","each_rank()","each_rank()","each_row()","each_row()","each_stored_with_index()","each_stored_with_index()","each_stored_with_indices()","each_stored_with_indices()","each_with_indices()","each_with_indices()","effective_dim()","effective_dim()","effective_dimensions()","effective_dimensions()","extract()","eye()","eye()","factorize_lu()","factorize_lu()","findgen()","findgen()","findgen()","flat_map()","flat_map()","gemm()","gemv()","gesdd()","gesdd()","gesvd()","gesvd()","gesvd()","getrf!()","getrf!()","guess_byte_order()","guess_byte_order()","guess_dtype()","guess_dtype()","guess_dtype_from_mdtype()","hermitian?()","hermitian?()","identity()","identity()","ignore_padding()","ignore_padding()","indgen()","indgen()","indgen()","initialize_copy()","initialize_copy()","inject_along_dim()","inject_along_dim()","inject_rank()","inject_rank()","inspect()","integer_dtype?()","integer_dtype?()","inverse()","inverse()","invert()","invert()","invert!()","invert!()","is_ref?()","is_ref?()","laswp()","laswp()","laswp()","laswp!()","laswp!()","layer()","layer()","linspace()","list?()","list?()","load()","load_array()","load_coordinate()","load_file()","load_file()","load_mat()","logspace()","map()","map()","map!()","map!()","matches?()","max()","max()","max()","mean()","mean()","min()","min()","min()","min_dtype()","min_dtype()","new()","new()","new()","new()","new()","new()","new()","new()","norm2()","nrm2()","nrm2()","nvector?()","nvector?()","of()","offset()","offset()","ones()","ones()","ones()","ones_like()","ones_like()","orientation()","padded_bytes()","percent_of()","permute_columns()","permute_columns()","permute_columns!()","permute_columns!()","random()","random()","random()","rank()","rank()","read()","read()","read_packed()","read_packed()","read_packed()","read_packed()","read_packed()","read_packed()","reduce_along_dim()","reduce_along_dim()","repack()","repacked_data()","repacked_indices()","rot()","rot!()","rotg()","row()","row()","rows()","rows()","save()","save_array()","save_coordinate()","seek_and_read_file_header()","seq()","seq()","seq()","shape()","shape()","shuffle()","shuffle()","shuffle!()","shuffle!()","size()","size()","size()","size()","size()","size()","slice()","slice()","small?()","sorted_indices()","std()","std()","stype()","stype()","sum()","sum()","supershape()","supershape()","symmetric?()","symmetric?()","to_a()","to_a()","to_a()","to_f()","to_f()","to_flat_a()","to_flat_a()","to_flat_array()","to_flat_array()","to_h()","to_h()","to_hash()","to_hash()","to_nm()","to_nm()","to_ruby()","to_ruby()","to_ruby()","to_s()","transpose()","transpose()","unpacked_data()","upcast()","upcast()","variance()","variance()","vector?()","vector?()","write()","write()","write_packed()","write_packed()","write_packed()","write_packed()","write_packed()","yale?()","yale?()","yale_a()","yale_d()","yale_ia()","yale_ija()","yale_ja()","yale_ja_at()","yale_ja_d_keys_at()","yale_ja_d_keys_set_at()","yale_ja_d_keys_sorted_set_at()","yale_ja_set_at()","yale_ja_sorted_set_at()","yale_lu()","yale_nd_row()","yale_nd_row_as_array()","yale_nd_row_as_hash()","yale_nd_row_as_set()","yale_nd_row_as_sorted_set()","yale_nd_row_size()","yale_row_as_array()","yale_row_as_hash()","yale_row_as_set()","yale_row_as_sorted_set()","yale_size()","zeroes()","zeroes()","zeroes()","zeros()","zeros()","zeros()","zeros_like()","zeros_like()","contributing","history","license","readme","binary_format"],"longSearchIndex":["array","datatypeerror","n","nmatrix","nmatrix::blas","nmatrix::io","nmatrix::io::market","nmatrix::io::matlab","nmatrix::io::matlab::mat5reader","nmatrix::io::matlab::mat5reader::compressed","nmatrix::io::matlab::mat5reader::element","nmatrix::io::matlab::mat5reader::elementdataioerror","nmatrix::io::matlab::mat5reader::header","nmatrix::io::matlab::mat5reader::matrixdata","nmatrix::io::matlab::mat5reader::rawelement","nmatrix::io::matlab::mat5reader::tag","nmatrix::io::matlab::matreader","nmatrix::lapack","nmatrix::yalefunctions","nvector","nvector","object","rspec","rspec::matchers","rspec::matchers::builtin","rspec::matchers::builtin::bewithin","storagetypeerror","unknown","nmatrix#==()","nmatrix#==()","nmatrix#[]()","nmatrix::[]()","nmatrix#[]()","nmatrix::[]()","nvector#[]()","nmatrix#[]=()","nmatrix#[]=()","nvector#[]=()","nmatrix#abs()","nmatrix#abs()","nmatrix#abs_dtype()","nmatrix#abs_dtype()","nvector#absolute_sum()","nmatrix#alloc_svd_result()","nmatrix#alloc_svd_result()","nmatrix::blas::asum()","nvector#asum()","nmatrix::bindgen()","nmatrix::bindgen()","nvector::bindgen()","nvector#binned_sorted_indices()","nmatrix#capacity()","nmatrix#capacity()","nmatrix#cast()","nmatrix#cast()","nmatrix#cast_full()","nmatrix#cast_full()","nmatrix::cindgen()","nmatrix::cindgen()","nvector::cindgen()","nmatrix::lapack::clapack_gesv()","nmatrix::lapack::clapack_posv()","nmatrix#col()","nmatrix#col()","nmatrix#cols()","nmatrix#cols()","nmatrix#column()","nmatrix#column()","nmatrix#complex_conjugate()","nmatrix#complex_conjugate()","nmatrix#complex_conjugate!()","nmatrix#complex_conjugate!()","nmatrix::io::matlab::complex_merge()","nmatrix::io::matlab::mat5reader::compressed#compressed()","nmatrix#conjugate_transpose()","nmatrix#conjugate_transpose()","nmatrix::io::matlab::mat5reader::compressed#content()","nmatrix#default_value()","nmatrix#default_value()","nmatrix#dense?()","nmatrix#dense?()","nmatrix#det()","nmatrix#det()","nmatrix#det_exact()","nmatrix#det_exact()","nmatrix::diag()","nmatrix::diag()","nmatrix::diagonal()","nmatrix::diagonal()","nmatrix::diagonals()","nmatrix::diagonals()","nmatrix#dim()","nmatrix#dim()","nvector#dim()","nmatrix#dimensions()","nmatrix#dimensions()","nmatrix#dot()","nmatrix#dot()","nmatrix#dtype()","nmatrix#dtype()","nmatrix#each()","nmatrix#each()","nmatrix::io::matlab::mat5reader#each()","nmatrix#each_along_dim()","nmatrix#each_along_dim()","nmatrix#each_column()","nmatrix#each_column()","nmatrix#each_layer()","nmatrix#each_layer()","nmatrix#each_ordered_stored_with_indices()","nmatrix#each_ordered_stored_with_indices()","nmatrix#each_rank()","nmatrix#each_rank()","nmatrix#each_row()","nmatrix#each_row()","nmatrix#each_stored_with_index()","nmatrix#each_stored_with_index()","nmatrix#each_stored_with_indices()","nmatrix#each_stored_with_indices()","nmatrix#each_with_indices()","nmatrix#each_with_indices()","nmatrix#effective_dim()","nmatrix#effective_dim()","nmatrix#effective_dimensions()","nmatrix#effective_dimensions()","nmatrix::io::matlab::mat5reader::compressed#extract()","nmatrix::eye()","nmatrix::eye()","nmatrix#factorize_lu()","nmatrix#factorize_lu()","nmatrix::findgen()","nmatrix::findgen()","nvector::findgen()","nmatrix#flat_map()","nmatrix#flat_map()","nmatrix::blas::gemm()","nmatrix::blas::gemv()","nmatrix#gesdd()","nmatrix#gesdd()","nmatrix#gesvd()","nmatrix#gesvd()","nmatrix::lapack::gesvd()","nmatrix#getrf!()","nmatrix#getrf!()","nmatrix::io::matlab::mat5reader#guess_byte_order()","nmatrix::io::matlab::matreader#guess_byte_order()","nmatrix::guess_dtype()","nmatrix::guess_dtype()","nmatrix::io::matlab::mat5reader::matrixdata#guess_dtype_from_mdtype()","nmatrix#hermitian?()","nmatrix#hermitian?()","nmatrix::identity()","nmatrix::identity()","nmatrix::io::matlab::mat5reader::element#ignore_padding()","nmatrix::io::matlab::mat5reader::matrixdata#ignore_padding()","nmatrix::indgen()","nmatrix::indgen()","nvector::indgen()","nmatrix#initialize_copy()","nmatrix#initialize_copy()","nmatrix#inject_along_dim()","nmatrix#inject_along_dim()","nmatrix#inject_rank()","nmatrix#inject_rank()","nmatrix::io::matlab::mat5reader::tag#inspect()","nmatrix#integer_dtype?()","nmatrix#integer_dtype?()","nmatrix#inverse()","nmatrix#inverse()","nmatrix#invert()","nmatrix#invert()","nmatrix#invert!()","nmatrix#invert!()","nmatrix#is_ref?()","nmatrix#is_ref?()","nmatrix#laswp()","nmatrix#laswp()","nmatrix::lapack::laswp()","nmatrix#laswp!()","nmatrix#laswp!()","nmatrix#layer()","nmatrix#layer()","nvector::linspace()","nmatrix#list?()","nmatrix#list?()","nmatrix::io::market::load()","nmatrix::io::market::load_array()","nmatrix::io::market::load_coordinate()","nmatrix::load_file()","nmatrix::load_file()","nmatrix::io::matlab::load_mat()","nvector::logspace()","nmatrix#map()","nmatrix#map()","nmatrix#map!()","nmatrix#map!()","rspec::matchers::builtin::bewithin#matches?()","nmatrix#max()","nmatrix#max()","nvector#max()","nmatrix#mean()","nmatrix#mean()","nmatrix#min()","nmatrix#min()","nvector#min()","nmatrix::min_dtype()","nmatrix::min_dtype()","nmatrix::new()","nmatrix::new()","nmatrix::io::matlab::mat5reader::new()","nmatrix::io::matlab::mat5reader::compressed::new()","nmatrix::io::matlab::mat5reader::elementdataioerror::new()","nmatrix::io::matlab::matreader::new()","nvector::new()","nvector::new()","nvector#norm2()","nmatrix::blas::nrm2()","nvector#nrm2()","nmatrix#nvector?()","nmatrix#nvector?()","rspec::matchers::builtin::bewithin#of()","nmatrix#offset()","nmatrix#offset()","nmatrix::ones()","nmatrix::ones()","nvector::ones()","nmatrix::ones_like()","nmatrix::ones_like()","nvector#orientation()","nmatrix::io::matlab::mat5reader::compressed#padded_bytes()","rspec::matchers::builtin::bewithin#percent_of()","nmatrix#permute_columns()","nmatrix#permute_columns()","nmatrix#permute_columns!()","nmatrix#permute_columns!()","nmatrix::random()","nmatrix::random()","nvector::random()","nmatrix#rank()","nmatrix#rank()","nmatrix::read()","nmatrix::read()","nmatrix::io::matlab::mat5reader::compressed#read_packed()","nmatrix::io::matlab::mat5reader::element#read_packed()","nmatrix::io::matlab::mat5reader::header#read_packed()","nmatrix::io::matlab::mat5reader::matrixdata#read_packed()","nmatrix::io::matlab::mat5reader::rawelement#read_packed()","nmatrix::io::matlab::mat5reader::tag#read_packed()","nmatrix#reduce_along_dim()","nmatrix#reduce_along_dim()","nmatrix::io::matlab::repack()","nmatrix::io::matlab::mat5reader::matrixdata#repacked_data()","nmatrix::io::matlab::mat5reader::matrixdata#repacked_indices()","nmatrix::blas::rot()","nmatrix::blas::rot!()","nmatrix::blas::rotg()","nmatrix#row()","nmatrix#row()","nmatrix#rows()","nmatrix#rows()","nmatrix::io::market::save()","nmatrix::io::market::save_array()","nmatrix::io::market::save_coordinate()","nmatrix::io::matlab::mat5reader#seek_and_read_file_header()","nmatrix::seq()","nmatrix::seq()","nvector::seq()","nmatrix#shape()","nmatrix#shape()","nmatrix#shuffle()","nmatrix#shuffle()","nmatrix#shuffle!()","nmatrix#shuffle!()","nmatrix#size()","nmatrix#size()","nmatrix::size()","nmatrix::size()","nmatrix::io::matlab::mat5reader::tag#size()","nvector#size()","nmatrix#slice()","nmatrix#slice()","nmatrix::io::matlab::mat5reader::tag#small?()","nvector#sorted_indices()","nmatrix#std()","nmatrix#std()","nmatrix#stype()","nmatrix#stype()","nmatrix#sum()","nmatrix#sum()","nmatrix#supershape()","nmatrix#supershape()","nmatrix#symmetric?()","nmatrix#symmetric?()","nmatrix#to_a()","nmatrix#to_a()","nmatrix::io::matlab::mat5reader#to_a()","nmatrix#to_f()","nmatrix#to_f()","nmatrix#to_flat_a()","nmatrix#to_flat_a()","nmatrix#to_flat_array()","nmatrix#to_flat_array()","nmatrix#to_h()","nmatrix#to_h()","nmatrix#to_hash()","nmatrix#to_hash()","array#to_nm()","nmatrix::io::matlab::mat5reader::matrixdata#to_nm()","nmatrix::io::matlab::mat5reader#to_ruby()","nmatrix::io::matlab::mat5reader::element#to_ruby()","nmatrix::io::matlab::mat5reader::matrixdata#to_ruby()","nmatrix::io::matlab::mat5reader::elementdataioerror#to_s()","nmatrix#transpose()","nmatrix#transpose()","nmatrix::io::matlab::mat5reader::matrixdata#unpacked_data()","nmatrix::upcast()","nmatrix::upcast()","nmatrix#variance()","nmatrix#variance()","nmatrix#vector?()","nmatrix#vector?()","nmatrix#write()","nmatrix#write()","nmatrix::io::matlab::mat5reader::compressed#write_packed()","nmatrix::io::matlab::mat5reader::element#write_packed()","nmatrix::io::matlab::mat5reader::header#write_packed()","nmatrix::io::matlab::mat5reader::matrixdata#write_packed()","nmatrix::io::matlab::mat5reader::tag#write_packed()","nmatrix#yale?()","nmatrix#yale?()","nmatrix::yalefunctions#yale_a()","nmatrix::yalefunctions#yale_d()","nmatrix::yalefunctions#yale_ia()","nmatrix::yalefunctions#yale_ija()","nmatrix::yalefunctions#yale_ja()","nmatrix::yalefunctions#yale_ja_at()","nmatrix::yalefunctions#yale_ja_d_keys_at()","nmatrix::yalefunctions#yale_ja_d_keys_set_at()","nmatrix::yalefunctions#yale_ja_d_keys_sorted_set_at()","nmatrix::yalefunctions#yale_ja_set_at()","nmatrix::yalefunctions#yale_ja_sorted_set_at()","nmatrix::yalefunctions#yale_lu()","nmatrix::yalefunctions#yale_nd_row()","nmatrix::yalefunctions#yale_nd_row_as_array()","nmatrix::yalefunctions#yale_nd_row_as_hash()","nmatrix::yalefunctions#yale_nd_row_as_set()","nmatrix::yalefunctions#yale_nd_row_as_sorted_set()","nmatrix::yalefunctions#yale_nd_row_size()","nmatrix::yalefunctions#yale_row_as_array()","nmatrix::yalefunctions#yale_row_as_hash()","nmatrix::yalefunctions#yale_row_as_set()","nmatrix::yalefunctions#yale_row_as_sorted_set()","nmatrix::yalefunctions#yale_size()","nmatrix::zeroes()","nmatrix::zeroes()","nvector::zeroes()","nmatrix::zeros()","nmatrix::zeros()","nvector::zeros()","nmatrix::zeros_like()","nmatrix::zeros_like()","","","","",""],"info":[["Array","","Array.html","","<p>Classes and Modules #\n"],["DataTypeError","","DataTypeError.html","","<p>Exception raised when there&#39;s a problem with data.\n"],["N","","N.html","",""],["NMatrix","","NMatrix.html","",""],["NMatrix::BLAS","","NMatrix/BLAS.html","",""],["NMatrix::IO","","NMatrix/IO.html","","<p>Read and write extensions for NMatrix. These are only loaded when needed.\n"],["NMatrix::IO::Market","","NMatrix/IO/Market.html","",""],["NMatrix::IO::Matlab","","NMatrix/IO/Matlab.html","",""],["NMatrix::IO::Matlab::Mat5Reader","","NMatrix/IO/Matlab/Mat5Reader.html","","<p>Reader (and eventual writer) for a version 5 .mat file.\n"],["NMatrix::IO::Matlab::Mat5Reader::Compressed","","NMatrix/IO/Matlab/Mat5Reader/Compressed.html","",""],["NMatrix::IO::Matlab::Mat5Reader::Element","","NMatrix/IO/Matlab/Mat5Reader/Element.html","",""],["NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError","","NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html","",""],["NMatrix::IO::Matlab::Mat5Reader::Header","","NMatrix/IO/Matlab/Mat5Reader/Header.html","","<p>Internal Classes #\n"],["NMatrix::IO::Matlab::Mat5Reader::MatrixData","","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html","",""],["NMatrix::IO::Matlab::Mat5Reader::RawElement","","NMatrix/IO/Matlab/Mat5Reader/RawElement.html","","<p>Doesn&#39;t unpack the contents of the element, e.g., if we want to handle\nmanually, or pass the raw …\n"],["NMatrix::IO::Matlab::Mat5Reader::Tag","","NMatrix/IO/Matlab/Mat5Reader/Tag.html","",""],["NMatrix::IO::Matlab::MatReader","","NMatrix/IO/Matlab/MatReader.html","","<p>Class for parsing a .mat file stream.\n<p>The full format of .mat files is available here:\n<p>www.mathworks.com/help/pdf_doc/matlab/matfile_format.pdf …\n"],["NMatrix::LAPACK","","NMatrix/LAPACK.html","",""],["NMatrix::YaleFunctions","","NMatrix/YaleFunctions.html","","<p>This module stores methods that are useful for debugging Yale matrices,\ni.e. the ones with <code>:yale</code> stype. …\n"],["NVector","","NVector.html","","<p>This is a specific type of NMatrix in which only one dimension is not 1.\nAlthough it is stored as a dim-2, …\n"],["NVector","","NVector.html","",""],["Object","","Object.html","",""],["RSpec","","RSpec.html","",""],["RSpec::Matchers","","RSpec/Matchers.html","",""],["RSpec::Matchers::BuiltIn","","RSpec/Matchers/BuiltIn.html","",""],["RSpec::Matchers::BuiltIn::BeWithin","","RSpec/Matchers/BuiltIn/BeWithin.html","",""],["StorageTypeError","","StorageTypeError.html","","<p>Exception raised when something goes wrong with the storage of a matrix.\n"],["unknown","","unknown.html","",""],["==","NMatrix","NMatrix.html#method-i-3D-3D","(p1)","<p>Equality operator. Returns a single true or false value indicating whether\nthe matrices are equivalent. …\n"],["==","NMatrix","NMatrix.html#method-i-3D-3D","(p1)","<p>Equality operator. Returns a single true or false value indicating whether\nthe matrices are equivalent. …\n"],["[]","NMatrix","NMatrix.html#method-i-5B-5D","(*args)","<p>Access the contents of an NMatrix at given coordinates by reference.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>]  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["[]","NMatrix","NMatrix.html#method-c-5B-5D","(*params)","<p>You can use the old <code>N</code> constant in this way:\n\n<pre>N = NMatrix\nN[1, 2, 3]</pre>\n<p>NMatrix needs to have a succinct way …\n"],["[]","NMatrix","NMatrix.html#method-i-5B-5D","(*args)","<p>Access the contents of an NMatrix at given coordinates by reference.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>]  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>[<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>] <span class=\"ruby-comment\">#=&gt; ...</span>\n</pre>\n"],["[]","NMatrix","NMatrix.html#method-c-5B-5D","(*params)","<p>You can use the old <code>N</code> constant in this way:\n\n<pre>N = NMatrix\nN[1, 2, 3]</pre>\n<p>NMatrix needs to have a succinct way …\n"],["[]","NVector","NVector.html#method-i-5B-5D","(i)","<p>Retrieves an element or return a slice.\n<p>Examples:\n\n<pre>u = NVector.new(3, [10, 20, 30])\nu[0]              # ...</pre>\n"],["[]=","NMatrix","NMatrix.html#method-i-5B-5D-3D","(*args)","<p>Modify the contents of an NMatrix in the given cell\n\n<pre>n[3,3] = 5.0</pre>\n<p>Also returns the new contents, so you …\n"],["[]=","NMatrix","NMatrix.html#method-i-5B-5D-3D","(*args)","<p>Modify the contents of an NMatrix in the given cell\n\n<pre>n[3,3] = 5.0</pre>\n<p>Also returns the new contents, so you …\n"],["[]=","NVector","NVector.html#method-i-5B-5D-3D","(i, val)","<p>Stores <code>value</code> at position <code>index</code>.\n"],["abs","NMatrix","NMatrix.html#method-i-abs","()","<p>Maps all values in a matrix to their absolute values.\n"],["abs","NMatrix","NMatrix.html#method-i-abs","()","<p>Maps all values in a matrix to their absolute values.\n"],["abs_dtype","NMatrix","NMatrix.html#method-i-abs_dtype","()","<p>Returns the dtype of the result of a call to #abs. In most cases, this is\nthe same as dtype; it should …\n"],["abs_dtype","NMatrix","NMatrix.html#method-i-abs_dtype","()","<p>Returns the dtype of the result of a call to #abs. In most cases, this is\nthe same as dtype; it should …\n"],["absolute_sum","NVector","NVector.html#method-i-absolute_sum","(incx=1, n=nil)",""],["alloc_svd_result","NMatrix","NMatrix.html#method-i-alloc_svd_result","()",""],["alloc_svd_result","NMatrix","NMatrix.html#method-i-alloc_svd_result","()",""],["asum","NMatrix::BLAS","NMatrix/BLAS.html#method-c-asum","(x, incx = 1, n = nil)","<p>Calculate the sum of absolute values of the entries of a vector\n<code>x</code> of size <code>n</code>\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; an NMatrix …\n"],["asum","NVector","NVector.html#method-i-asum","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["bindgen","NMatrix","NMatrix.html#method-c-bindgen","(shape)","<p>Returns a byte NMatrix. Equivalent to <code>seq(n, dtype: :byte)</code>.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Shape of the sequence. …\n"],["bindgen","NMatrix","NMatrix.html#method-c-bindgen","(shape)","<p>Returns a byte NMatrix. Equivalent to <code>seq(n, dtype: :byte)</code>.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Shape of the sequence. …\n"],["bindgen","NVector","NVector.html#method-c-bindgen","(n)","<p>Returns a byte NVector. Equivalent to <code>seq(n, :byte)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence.\n"],["binned_sorted_indices","NVector","NVector.html#method-i-binned_sorted_indices","()","<p>Returns an array of arrays of indices ordered by value sorted. Functions\nbasically like <code>sorted_indices</code> …\n"],["capacity","NMatrix","NMatrix.html#method-i-capacity","()","<p>Find the capacity of an NMatrix. The capacity only differs from the size\nfor Yale matrices, which occasionally …\n"],["capacity","NMatrix","NMatrix.html#method-i-capacity","()","<p>Find the capacity of an NMatrix. The capacity only differs from the size\nfor Yale matrices, which occasionally …\n"],["cast","NMatrix","NMatrix.html#method-i-cast","(*params)","<p>This is a user-friendly helper for calling #cast_full. The easiest way to\ncall this function is using …\n"],["cast","NMatrix","NMatrix.html#method-i-cast","(*params)","<p>This is a user-friendly helper for calling #cast_full. The easiest way to\ncall this function is using …\n"],["cast_full","NMatrix","NMatrix.html#method-i-cast_full","(p1, p2, p3)","<p>Copy constructor for changing dtypes and stypes.\n"],["cast_full","NMatrix","NMatrix.html#method-i-cast_full","(p1, p2, p3)","<p>Copy constructor for changing dtypes and stypes.\n"],["cindgen","NMatrix","NMatrix.html#method-c-cindgen","(shape)","<p>Returns a complex NMatrix. Equivalent to <code>seq(n, dtype:\n:complex64)</code>.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Shape of the …\n"],["cindgen","NMatrix","NMatrix.html#method-c-cindgen","(shape)","<p>Returns a complex NMatrix. Equivalent to <code>seq(n, dtype:\n:complex64)</code>.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Shape of the …\n"],["cindgen","NVector","NVector.html#method-c-cindgen","(n)","<p>Returns a complex NVector. Equivalent to <code>seq(n, :complex64)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence. …\n"],["clapack_gesv","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_gesv","(order, n, nrhs, a, lda, ipiv, b, ldb)","<p>Computes the solution to a system of linear equations\n\n<pre>A * X = B,</pre>\n<p>where A is an N-by-N matrix and X and …\n"],["clapack_posv","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-clapack_posv","(order, uplo, n, nrhs, a, lda, b, ldb)","<p>TODO Complete this description.\n<p>Computes the solution to a real system of linear equations\n\n<pre>A * X = B,</pre>\n"],["col","NMatrix","NMatrix.html#method-i-col","(column_number, get_by = :copy)",""],["col","NMatrix","NMatrix.html#method-i-col","(column_number, get_by = :copy)",""],["cols","NMatrix","NMatrix.html#method-i-cols","()","<p>This shortcut use #shape to return the number of columns (the second\ndimension) of the matrix.\n"],["cols","NMatrix","NMatrix.html#method-i-cols","()","<p>This shortcut use #shape to return the number of columns (the second\ndimension) of the matrix.\n"],["column","NMatrix","NMatrix.html#method-i-column","(column_number, get_by = :copy)","<p>Returns the column specified. Uses slicing by copy as default.\n<p><strong>Arguments</strong> :\n<p><code>column_number</code> -&gt; Integer …\n"],["column","NMatrix","NMatrix.html#method-i-column","(column_number, get_by = :copy)","<p>Returns the column specified. Uses slicing by copy as default.\n<p><strong>Arguments</strong> :\n<p><code>column_number</code> -&gt; Integer …\n"],["complex_conjugate","NMatrix","NMatrix.html#method-i-complex_conjugate","(new_stype = self.stype)","<p>Get the complex conjugate of this matrix. See also complex_conjugate! for\nan in-place operation (provided …\n"],["complex_conjugate","NMatrix","NMatrix.html#method-i-complex_conjugate","(new_stype = self.stype)","<p>Get the complex conjugate of this matrix. See also complex_conjugate! for\nan in-place operation (provided …\n"],["complex_conjugate!","NMatrix","NMatrix.html#method-i-complex_conjugate-21","()","<p>Transform the matrix (in-place) to its complex conjugate. Only works on\ncomplex matrices.\n<p>FIXME: For non-complex …\n"],["complex_conjugate!","NMatrix","NMatrix.html#method-i-complex_conjugate-21","()","<p>Transform the matrix (in-place) to its complex conjugate. Only works on\ncomplex matrices.\n<p>FIXME: For non-complex …\n"],["complex_merge","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-complex_merge","(p1, p2, p3)","<p>Take two byte-strings (real and imaginary) and treat them as if they\ncontain a sequence of data of type …\n"],["compressed","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-compressed","()",""],["conjugate_transpose","NMatrix","NMatrix.html#method-i-conjugate_transpose","()","<p>Calculate the conjugate transpose of a matrix. If your dtype is already\ncomplex, this should only require …\n"],["conjugate_transpose","NMatrix","NMatrix.html#method-i-conjugate_transpose","()","<p>Calculate the conjugate transpose of a matrix. If your dtype is already\ncomplex, this should only require …\n"],["content","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-content","()",""],["default_value","NMatrix","NMatrix.html#method-i-default_value","()","<p>Get the default value for the matrix. For dense, this is undefined and will\nreturn Qnil. For list, it …\n"],["default_value","NMatrix","NMatrix.html#method-i-default_value","()","<p>Get the default value for the matrix. For dense, this is undefined and will\nreturn Qnil. For list, it …\n"],["dense?","NMatrix","NMatrix.html#method-i-dense-3F","()","<p>Shortcut functions for quickly determining a matrix&#39;s stype.\n"],["dense?","NMatrix","NMatrix.html#method-i-dense-3F","()","<p>Shortcut functions for quickly determining a matrix&#39;s stype.\n"],["det","NMatrix","NMatrix.html#method-i-det","()","<p>Calculate the determinant by way of LU decomposition. This is accomplished\nusing clapack_getrf, and then …\n"],["det","NMatrix","NMatrix.html#method-i-det","()","<p>Calculate the determinant by way of LU decomposition. This is accomplished\nusing clapack_getrf, and then …\n"],["det_exact","NMatrix","NMatrix.html#method-i-det_exact","()","<p>Calculate the exact determinant of a dense matrix.\n<p>Returns nil for dense matrices which are not square …\n"],["det_exact","NMatrix","NMatrix.html#method-i-det_exact","()","<p>Calculate the exact determinant of a dense matrix.\n<p>Returns nil for dense matrices which are not square …\n"],["diag","NMatrix","NMatrix.html#method-c-diag","(entries, opts={})",""],["diag","NMatrix","NMatrix.html#method-c-diag","(entries, opts={})",""],["diagonal","NMatrix","NMatrix.html#method-c-diagonal","(entries, opts={})","<p>Creates a matrix filled with specified diagonals.\n<p><strong>Arguments</strong> :\n<p><code>entries</code> -&gt; Array containing input values …\n"],["diagonal","NMatrix","NMatrix.html#method-c-diagonal","(entries, opts={})","<p>Creates a matrix filled with specified diagonals.\n<p><strong>Arguments</strong> :\n<p><code>entries</code> -&gt; Array containing input values …\n"],["diagonals","NMatrix","NMatrix.html#method-c-diagonals","(entries, opts={})",""],["diagonals","NMatrix","NMatrix.html#method-c-diagonals","(entries, opts={})",""],["dim","NMatrix","NMatrix.html#method-i-dim","()",""],["dim","NMatrix","NMatrix.html#method-i-dim","()",""],["dim","NVector","NVector.html#method-i-dim","()","<p>Returns the dimension of a vector, which is 1.\n"],["dimensions","NMatrix","NMatrix.html#method-i-dimensions","()","<p>Get the number of dimensions of a matrix.\n<p>In other words, if you set your matrix to be 3x4, the dim is …\n"],["dimensions","NMatrix","NMatrix.html#method-i-dimensions","()","<p>Get the number of dimensions of a matrix.\n<p>In other words, if you set your matrix to be 3x4, the dim is …\n"],["dot","NMatrix","NMatrix.html#method-i-dot","(p1)","<p>Matrix multiply (dot product): against another matrix or a vector.\n<p>For elementwise, use * instead.\n<p>The …\n"],["dot","NMatrix","NMatrix.html#method-i-dot","(p1)","<p>Matrix multiply (dot product): against another matrix or a vector.\n<p>For elementwise, use * instead.\n<p>The …\n"],["dtype","NMatrix","NMatrix.html#method-i-dtype","()","<p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,\n:int64, :float32, :float64, …\n"],["dtype","NMatrix","NMatrix.html#method-i-dtype","()","<p>Get the data type (dtype) of a matrix, e.g., :byte, :int8, :int16, :int32,\n:int64, :float32, :float64, …\n"],["each","NMatrix","NMatrix.html#method-i-each","(&bl)","<p>Enumerate through the matrix. @see Enumerable#each\n<p>For dense, this actually calls a specialized each iterator …\n"],["each","NMatrix","NMatrix.html#method-i-each","(&bl)","<p>Enumerate through the matrix. @see Enumerable#each\n<p>For dense, this actually calls a specialized each iterator …\n"],["each","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-each","(&block)",""],["each_along_dim","NMatrix","NMatrix.html#method-i-each_along_dim","(dimen=0, get_by=:reference)",""],["each_along_dim","NMatrix","NMatrix.html#method-i-each_along_dim","(dimen=0, get_by=:reference)",""],["each_column","NMatrix","NMatrix.html#method-i-each_column","(get_by=:reference)","<p>Iterate through each column, referencing it as an NMatrix slice.\n"],["each_column","NMatrix","NMatrix.html#method-i-each_column","(get_by=:reference)","<p>Iterate through each column, referencing it as an NMatrix slice.\n"],["each_layer","NMatrix","NMatrix.html#method-i-each_layer","(get_by=:reference)","<p>Iterate through each layer, referencing it as an NMatrix slice.\n<p>Note: If you have a 3-dimensional matrix, …\n"],["each_layer","NMatrix","NMatrix.html#method-i-each_layer","(get_by=:reference)","<p>Iterate through each layer, referencing it as an NMatrix slice.\n<p>Note: If you have a 3-dimensional matrix, …\n"],["each_ordered_stored_with_indices","NMatrix","NMatrix.html#method-i-each_ordered_stored_with_indices","()","<p>Very similar to #each_stored_with_indices. The key difference is that it\nenforces matrix ordering rather …\n"],["each_ordered_stored_with_indices","NMatrix","NMatrix.html#method-i-each_ordered_stored_with_indices","()","<p>Very similar to #each_stored_with_indices. The key difference is that it\nenforces matrix ordering rather …\n"],["each_rank","NMatrix","NMatrix.html#method-i-each_rank","(dimen=0, get_by=:reference)","<p>Generic for @each_row, @each_col\n<p>Iterate through each rank by reference.\n<p>@param [Fixnum] dimen the rank …\n"],["each_rank","NMatrix","NMatrix.html#method-i-each_rank","(dimen=0, get_by=:reference)","<p>Generic for @each_row, @each_col\n<p>Iterate through each rank by reference.\n<p>@param [Fixnum] dimen the rank …\n"],["each_row","NMatrix","NMatrix.html#method-i-each_row","(get_by=:reference)","<p>Iterate through each row, referencing it as an NMatrix slice.\n"],["each_row","NMatrix","NMatrix.html#method-i-each_row","(get_by=:reference)","<p>Iterate through each row, referencing it as an NMatrix slice.\n"],["each_stored_with_index","NMatrix","NMatrix.html#method-i-each_stored_with_index","(&block)","<p>Allow iteration across a vector NMatrix&#39;s stored values. See also\n@each_stored_with_indices\n"],["each_stored_with_index","NMatrix","NMatrix.html#method-i-each_stored_with_index","(&block)","<p>Allow iteration across a vector NMatrix&#39;s stored values. See also\n@each_stored_with_indices\n"],["each_stored_with_indices","NMatrix","NMatrix.html#method-i-each_stored_with_indices","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["each_stored_with_indices","NMatrix","NMatrix.html#method-i-each_stored_with_indices","()","<p>Iterate over the stored entries of any matrix. For dense and yale, this\niterates over non-zero entries; …\n"],["each_with_indices","NMatrix","NMatrix.html#method-i-each_with_indices","()","<p>Iterate over all entries of any matrix in standard storage order (as with\n#each), and include the indices. …\n"],["each_with_indices","NMatrix","NMatrix.html#method-i-each_with_indices","()","<p>Iterate over all entries of any matrix in standard storage order (as with\n#each), and include the indices. …\n"],["effective_dim","NMatrix","NMatrix.html#method-i-effective_dim","()",""],["effective_dim","NMatrix","NMatrix.html#method-i-effective_dim","()",""],["effective_dimensions","NMatrix","NMatrix.html#method-i-effective_dimensions","()","<p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed\nto be less than or equal to …\n"],["effective_dimensions","NMatrix","NMatrix.html#method-i-effective_dimensions","()","<p>Returns the number of dimensions that don&#39;t have length 1. Guaranteed\nto be less than or equal to …\n"],["extract","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-extract","()",""],["eye","NMatrix","NMatrix.html#method-c-eye","(shape, opts={})","<p>Creates an identity matrix (square matrix rank 2).\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer for square …\n"],["eye","NMatrix","NMatrix.html#method-c-eye","(shape, opts={})","<p>Creates an identity matrix (square matrix rank 2).\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer for square …\n"],["factorize_lu","NMatrix","NMatrix.html#method-i-factorize_lu","()","<p>LU factorization of a matrix.\n<p>FIXME: For some reason, getrf seems to require that the matrix be\ntransposed …\n"],["factorize_lu","NMatrix","NMatrix.html#method-i-factorize_lu","()","<p>LU factorization of a matrix.\n<p>FIXME: For some reason, getrf seems to require that the matrix be\ntransposed …\n"],["findgen","NMatrix","NMatrix.html#method-c-findgen","(shape)","<p>Returns a float NMatrix. Equivalent to <code>seq(n, dtype:\n:float32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Shape of the sequence. …\n"],["findgen","NMatrix","NMatrix.html#method-c-findgen","(shape)","<p>Returns a float NMatrix. Equivalent to <code>seq(n, dtype:\n:float32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Shape of the sequence. …\n"],["findgen","NVector","NVector.html#method-c-findgen","(n)","<p>Returns a float NVector. Equivalent to <code>seq(n, :float32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence.\n"],["flat_map","NMatrix","NMatrix.html#method-i-flat_map","(&bl)","<p>call-seq:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">flat_map</span> <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Enumerator</span>\n<span class=\"ruby-identifier\">flat_map</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">elem</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-identifier\">block</span> } <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Array</span>\n</pre>\n<p>Maps using Enumerator (returns an  …\n"],["flat_map","NMatrix","NMatrix.html#method-i-flat_map","(&bl)","<p>call-seq:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">flat_map</span> <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Enumerator</span>\n<span class=\"ruby-identifier\">flat_map</span> { <span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">elem</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-identifier\">block</span> } <span class=\"ruby-operator\">-</span><span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-constant\">Array</span>\n</pre>\n<p>Maps using Enumerator (returns an  …\n"],["gemm","NMatrix::BLAS","NMatrix/BLAS.html#method-c-gemm","(a, b, c = nil, alpha = 1.0, beta = 0.0, transpose_a = false, transpose_b = false, m = nil, n = nil, k = nil, lda = nil, ldb = nil, ldc = nil)","<p>Updates the value of C via the matrix multiplication\n\n<pre>C = (alpha * A * B) + (beta * C)</pre>\n<p>where <code>alpha</code> and  …\n"],["gemv","NMatrix::BLAS","NMatrix/BLAS.html#method-c-gemv","(a, x, y = nil, alpha = 1.0, beta = 0.0, transpose_a = false, m = nil, n = nil, lda = nil, incx = nil, incy = nil)","<p>Implements matrix-vector product via\n\n<pre>y = (alpha * A * x) + (beta * y)</pre>\n<p>where <code>alpha</code> and <code>beta</code> are scalar values. …\n"],["gesdd","NMatrix","NMatrix.html#method-i-gesdd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesdd","NMatrix","NMatrix.html#method-i-gesdd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESDD function. This uses a divide-and-conquer …\n"],["gesvd","NMatrix","NMatrix.html#method-i-gesvd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function.\n<p>Optionally accepts …\n"],["gesvd","NMatrix","NMatrix.html#method-i-gesvd","(workspace_size=1)","<p>Compute the singular value decomposition of a matrix using LAPACK&#39;s\nGESVD function.\n<p>Optionally accepts …\n"],["gesvd","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-gesvd","(matrix, type = :both)","<p><strong>Arguments</strong> :\n<p><code>matrix</code> -&gt; matrix for which to compute the singular values\n##TODO make this a self\n<p><code>type</code> -&gt; …\n"],["getrf!","NMatrix","NMatrix.html#method-i-getrf-21","()","<p>LU factorization of a general M-by-N matrix <code>A</code> using partial\npivoting with row interchanges. Only works …\n"],["getrf!","NMatrix","NMatrix.html#method-i-getrf-21","()","<p>LU factorization of a general M-by-N matrix <code>A</code> using partial\npivoting with row interchanges. Only works …\n"],["guess_byte_order","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-guess_byte_order","()",""],["guess_byte_order","NMatrix::IO::Matlab::MatReader","NMatrix/IO/Matlab/MatReader.html#method-i-guess_byte_order","()",""],["guess_dtype","NMatrix","NMatrix.html#method-c-guess_dtype","(p1)","<p>Guess the dtype given a Ruby VALUE and return it as a symbol.\n<p>Not to be confused with nm_dtype_guess, …\n"],["guess_dtype","NMatrix","NMatrix.html#method-c-guess_dtype","(p1)","<p>Guess the dtype given a Ruby VALUE and return it as a symbol.\n<p>Not to be confused with nm_dtype_guess, …\n"],["guess_dtype_from_mdtype","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-guess_dtype_from_mdtype","()","<p>Try to determine what dtype and such to use.\n<p>TODO: Needs to be verified that unsigned MATLAB types are …\n"],["hermitian?","NMatrix","NMatrix.html#method-i-hermitian-3F","()","<p>Is this matrix hermitian?\n<p>Definition: en.wikipedia.org/wiki/Hermitian_matrix\n<p>For non-complex matrices, …\n"],["hermitian?","NMatrix","NMatrix.html#method-i-hermitian-3F","()","<p>Is this matrix hermitian?\n<p>Definition: en.wikipedia.org/wiki/Hermitian_matrix\n<p>For non-complex matrices, …\n"],["identity","NMatrix","NMatrix.html#method-c-identity","(shape, opts={})",""],["identity","NMatrix","NMatrix.html#method-c-identity","(shape, opts={})",""],["ignore_padding","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-ignore_padding","(packedio, bytes)",""],["ignore_padding","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-ignore_padding","(packedio, bytes)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["indgen","NMatrix","NMatrix.html#method-c-indgen","(shape)","<p>Returns an integer NMatrix. Equivalent to <code>seq(n, dtype:\n:int32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Shape of the sequence. …\n"],["indgen","NMatrix","NMatrix.html#method-c-indgen","(shape)","<p>Returns an integer NMatrix. Equivalent to <code>seq(n, dtype:\n:int32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Shape of the sequence. …\n"],["indgen","NVector","NVector.html#method-c-indgen","(n)","<p>Returns an integer NVector. Equivalent to <code>seq(n, :int32)</code>.\n<p><strong>Arguments</strong> :\n<p><code>n</code> -&gt; Size of the sequence.\n"],["initialize_copy","NMatrix","NMatrix.html#method-i-initialize_copy","(p1)","<p>Copy constructor for no change of dtype or stype (used for #initialize_copy\nhook).\n"],["initialize_copy","NMatrix","NMatrix.html#method-i-initialize_copy","(p1)","<p>Copy constructor for no change of dtype or stype (used for #initialize_copy\nhook).\n"],["inject_along_dim","NMatrix","NMatrix.html#method-i-inject_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["inject_along_dim","NMatrix","NMatrix.html#method-i-inject_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["inject_rank","NMatrix","NMatrix.html#method-i-inject_rank","(dimen=0, initial=nil, dtype=nil)","<p>Reduces an NMatrix using a supplied block over a specified dimension. The\nblock should behave the same …\n"],["inject_rank","NMatrix","NMatrix.html#method-i-inject_rank","(dimen=0, initial=nil, dtype=nil)","<p>Reduces an NMatrix using a supplied block over a specified dimension. The\nblock should behave the same …\n"],["inspect","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-inspect","()",""],["integer_dtype?","NMatrix","NMatrix.html#method-i-integer_dtype-3F","()","<p>Checks if dtype is an integer type\n"],["integer_dtype?","NMatrix","NMatrix.html#method-i-integer_dtype-3F","()","<p>Checks if dtype is an integer type\n"],["inverse","NMatrix","NMatrix.html#method-i-inverse","()",""],["inverse","NMatrix","NMatrix.html#method-i-inverse","()",""],["invert","NMatrix","NMatrix.html#method-i-invert","()","<p>Make a copy of the matrix, then invert it (requires LAPACK).\n<p><strong>Returns</strong> :\n<p>A dense NMatrix.\n"],["invert","NMatrix","NMatrix.html#method-i-invert","()","<p>Make a copy of the matrix, then invert it (requires LAPACK).\n<p><strong>Returns</strong> :\n<p>A dense NMatrix.\n"],["invert!","NMatrix","NMatrix.html#method-i-invert-21","()","<p>Use LAPACK to calculate the inverse of the matrix (in-place). Only works on\ndense matrices.\n<p>Note: If you …\n"],["invert!","NMatrix","NMatrix.html#method-i-invert-21","()","<p>Use LAPACK to calculate the inverse of the matrix (in-place). Only works on\ndense matrices.\n<p>Note: If you …\n"],["is_ref?","NMatrix","NMatrix.html#method-i-is_ref-3F","()","<p>Check to determine whether matrix is a reference to another matrix.\n"],["is_ref?","NMatrix","NMatrix.html#method-i-is_ref-3F","()","<p>Check to determine whether matrix is a reference to another matrix.\n"],["laswp","NMatrix","NMatrix.html#method-i-laswp","(ary)","<p>Permute the columns of a dense matrix using LASWP according to the order\ngiven in an Array <code>ary</code>. Not yet …\n"],["laswp","NMatrix","NMatrix.html#method-i-laswp","(ary)","<p>Permute the columns of a dense matrix using LASWP according to the order\ngiven in an Array <code>ary</code>. Not yet …\n"],["laswp","NMatrix::LAPACK","NMatrix/LAPACK.html#method-c-laswp","(matrix, ipiv)","\n<pre>laswp(matrix, ipiv) -&gt; NMatrix</pre>\n<p>Permute the columns of a matrix (in-place) according to the Array\n<code>ipiv</code> …\n"],["laswp!","NMatrix","NMatrix.html#method-i-laswp-21","(ary)","<p>In-place permute the columns of a dense matrix using LASWP according to the\norder given in an Array  …\n"],["laswp!","NMatrix","NMatrix.html#method-i-laswp-21","(ary)","<p>In-place permute the columns of a dense matrix using LASWP according to the\norder given in an Array  …\n"],["layer","NMatrix","NMatrix.html#method-i-layer","(layer_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>layer_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["layer","NMatrix","NMatrix.html#method-i-layer","(layer_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>layer_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["linspace","NVector","NVector.html#method-c-linspace","(a, b, n = 100)","<p>Returns a NVector with <code>n</code> values of dtype <code>:float64</code>\nequally spaced from <code>a</code> to <code>b</code>, inclusive.\n<p>See: www.mathworks.com/help/matlab/ref/linspace.html …\n"],["list?","NMatrix","NMatrix.html#method-i-list-3F","()",""],["list?","NMatrix","NMatrix.html#method-i-list-3F","()",""],["load","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load","(filename)","<p><strong>Arguments</strong> :\n<p><code>filename</code> -&gt; String with the filename to be saved.\n\n<p><strong>Raises</strong> :\n"],["load_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load_array","(file, converter, dtype, entry_type, symmetry)",""],["load_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-load_coordinate","(file, converter, dtype, entry_type, symmetry)","<p>Creates a :list NMatrix from a coordinate-list MatrixMarket file.\n"],["load_file","NMatrix","NMatrix.html#method-c-load_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>path</code> -&gt; The path to a version 5 .mat file.\n\n<p><strong>Returns</strong> :\n"],["load_file","NMatrix","NMatrix.html#method-c-load_file","(file_path)","<p><strong>Arguments</strong> :\n<p><code>path</code> -&gt; The path to a version 5 .mat file.\n\n<p><strong>Returns</strong> :\n"],["load_mat","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-load_mat","(file_path)",""],["logspace","NVector","NVector.html#method-c-logspace","(a, b, n = 100)","<p>Returns a NVector with <code>n</code> values of dtype <code>:float64</code>\nlogarithmically spaced from +10^a+ to +10^b+, inclusive. …\n"],["map","NMatrix","NMatrix.html#method-i-map","(&bl)","<p>Returns an NMatrix if a block is given. For an Array, use #flat_map\n"],["map","NMatrix","NMatrix.html#method-i-map","(&bl)","<p>Returns an NMatrix if a block is given. For an Array, use #flat_map\n"],["map!","NMatrix","NMatrix.html#method-i-map-21","()","<p>Maps in place. @see #map\n"],["map!","NMatrix","NMatrix.html#method-i-map-21","()","<p>Maps in place. @see #map\n"],["matches?","RSpec::Matchers::BuiltIn::BeWithin","RSpec/Matchers/BuiltIn/BeWithin.html#method-i-matches-3F","(actual)",""],["max","NMatrix","NMatrix.html#method-i-max","(dimen=0)","<p>Calculates the maximum along the specified dimension.\n<p>@see #inject_rank\n"],["max","NMatrix","NMatrix.html#method-i-max","(dimen=0)","<p>Calculates the maximum along the specified dimension.\n<p>@see #inject_rank\n"],["max","NVector","NVector.html#method-i-max","()","<p>Return the maximum element.\n"],["mean","NMatrix","NMatrix.html#method-i-mean","(dimen=0)","<p>Calculates the mean along the specified dimension.\n<p>This will force integer types to float64 dtype.\n<p>@see …\n"],["mean","NMatrix","NMatrix.html#method-i-mean","(dimen=0)","<p>Calculates the mean along the specified dimension.\n<p>This will force integer types to float64 dtype.\n<p>@see …\n"],["min","NMatrix","NMatrix.html#method-i-min","(dimen=0)","<p>Calculates the minimum along the specified dimension.\n<p>@see #inject_rank\n"],["min","NMatrix","NMatrix.html#method-i-min","(dimen=0)","<p>Calculates the minimum along the specified dimension.\n<p>@see #inject_rank\n"],["min","NVector","NVector.html#method-i-min","()","<p>Return the minimum element.\n"],["min_dtype","NMatrix","NMatrix.html#method-c-min_dtype","(p1)","<p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.\n"],["min_dtype","NMatrix","NMatrix.html#method-c-min_dtype","(p1)","<p>Get the minimum allowable dtype for a Ruby VALUE and return it as a symbol.\n"],["new","NMatrix","NMatrix.html#method-c-new","(*args)","<p>Create a new NMatrix.\n<p>The only mandatory argument is shape, which may be a positive integer or an\narray …\n"],["new","NMatrix","NMatrix.html#method-c-new","(*args)","<p>Create a new NMatrix.\n<p>The only mandatory argument is shape, which may be a positive integer or an\narray …\n"],["new","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-c-new","(stream, options = {})","<p>Instance Methods for Mat5Reader #\n"],["new","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-c-new","(stream = nil, byte_order = nil, content_or_bytes = nil)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Raises</strong> :\n"],["new","NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError","NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html#method-c-new","(tag = nil, msg = nil)",""],["new","NMatrix::IO::Matlab::MatReader","NMatrix/IO/Matlab/MatReader.html#method-c-new","(stream, options = {})","<p><strong>Raises</strong> :\n<p><code>ArgumentError</code> -&gt; First argument must be IO.\n\n\n"],["new","NVector","NVector.html#method-c-new","(*args)","<p>Creates a new NVector. See also NMatrix#initialize for a more detailed\nexplanation of the arguments. …\n"],["new","NVector","NVector.html#method-c-new","(*args)","<p>Creates a new NVector. See also NMatrix#initialize for a more detailed\nexplanation of the arguments. …\n"],["norm2","NVector","NVector.html#method-i-norm2","(incx=1, n=nil)",""],["nrm2","NMatrix::BLAS","NMatrix/BLAS.html#method-c-nrm2","(x, incx = 1, n = nil)","<p>Calculate the 2-norm of a vector <code>x</code> of size <code>n</code>\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; an NMatrix (will also allow an NMatrix …\n"],["nrm2","NVector","NVector.html#method-i-nrm2","(incx=1, n=nil)","<p>Arguments\n\n<pre>- +incx+ -&gt; the skip size (defaults to 1, no skip)\n- +n+ -&gt; the number of elements to include</pre>\n"],["nvector?","NMatrix","NMatrix.html#method-i-nvector-3F","()","<p>Shortcut function for determining whether the effective dimension is less\nthan the dimension. Useful …\n"],["nvector?","NMatrix","NMatrix.html#method-i-nvector-3F","()","<p>Shortcut function for determining whether the effective dimension is less\nthan the dimension. Useful …\n"],["of","RSpec::Matchers::BuiltIn::BeWithin","RSpec/Matchers/BuiltIn/BeWithin.html#method-i-of","(expected)",""],["offset","NMatrix","NMatrix.html#method-i-offset","()","<p>Get the offset (slice position) of a matrix. Typically all zeros, unless\nyou have a reference slice. …\n"],["offset","NMatrix","NMatrix.html#method-i-offset","()","<p>Get the offset (slice position) of a matrix. Typically all zeros, unless\nyou have a reference slice. …\n"],["ones","NMatrix","NMatrix.html#method-c-ones","(shape, opts={})","<p>Creates a matrix filled with ones.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or integer for square matrix) specifying …\n"],["ones","NMatrix","NMatrix.html#method-c-ones","(shape, opts={})","<p>Creates a matrix filled with ones.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or integer for square matrix) specifying …\n"],["ones","NVector","NVector.html#method-c-ones","(size, dtype = :float64)","<p>Creates a vector of ones with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array (or integer …\n"],["ones_like","NMatrix","NMatrix.html#method-c-ones_like","(nm)","<p>Creates a new matrix of ones with the same dtype and shape as the provided\nmatrix.\n<p>@param [NMatrix] nm …\n"],["ones_like","NMatrix","NMatrix.html#method-c-ones_like","(nm)","<p>Creates a new matrix of ones with the same dtype and shape as the provided\nmatrix.\n<p>@param [NMatrix] nm …\n"],["orientation","NVector","NVector.html#method-i-orientation","()","<p>Orientation defaults to row (e.g., [1,3] is a row of length 3). It may also\nbe column, e.g., for [5,1]. …\n"],["padded_bytes","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-padded_bytes","()",""],["percent_of","RSpec::Matchers::BuiltIn::BeWithin","RSpec/Matchers/BuiltIn/BeWithin.html#method-i-percent_of","(expected)",""],["permute_columns","NMatrix","NMatrix.html#method-i-permute_columns","(ary)",""],["permute_columns","NMatrix","NMatrix.html#method-i-permute_columns","(ary)",""],["permute_columns!","NMatrix","NMatrix.html#method-i-permute_columns-21","(ary)",""],["permute_columns!","NMatrix","NMatrix.html#method-i-permute_columns-21","(ary)",""],["random","NMatrix","NMatrix.html#method-c-random","(shape, opts={})","<p>Creates a <code>:dense</code> NMatrix with random numbers between 0 and 1\ngenerated by +Random::rand+. The parameter …\n"],["random","NMatrix","NMatrix.html#method-c-random","(shape, opts={})","<p>Creates a <code>:dense</code> NMatrix with random numbers between 0 and 1\ngenerated by +Random::rand+. The parameter …\n"],["random","NVector","NVector.html#method-c-random","(size, opts = {})","<p>Creates a vector with random numbers between 0 and 1 generated by\n+Random::rand+ with the dimensions …\n"],["rank","NMatrix","NMatrix.html#method-i-rank","(shape_idx, rank_idx, meth = :copy)","<p>Returns the rank (e.g., row, column, or layer) specified, using slicing by\ncopy as default.\n<p>See @row (dimension …\n"],["rank","NMatrix","NMatrix.html#method-i-rank","(shape_idx, rank_idx, meth = :copy)","<p>Returns the rank (e.g., row, column, or layer) specified, using slicing by\ncopy as default.\n<p>See @row (dimension …\n"],["read","NMatrix","NMatrix.html#method-c-read","(p1, p2 = v2)","<p>Binary file reader for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["read","NMatrix","NMatrix.html#method-c-read","(p1, p2 = v2)","<p>Binary file reader for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-read_packed","(packedio, options)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-read_packed","(packedio, options)",""],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Header","NMatrix/IO/Matlab/Mat5Reader/Header.html#method-i-read_packed","(packedio, options)",""],["read_packed","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-read_packed","(packedio, options)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["read_packed","NMatrix::IO::Matlab::Mat5Reader::RawElement","NMatrix/IO/Matlab/Mat5Reader/RawElement.html#method-i-read_packed","(packedio, options)",""],["read_packed","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-read_packed","(packedio, options)",""],["reduce_along_dim","NMatrix","NMatrix.html#method-i-reduce_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["reduce_along_dim","NMatrix","NMatrix.html#method-i-reduce_along_dim","(dimen=0, initial=nil, dtype=nil)",""],["repack","NMatrix::IO::Matlab","NMatrix/IO/Matlab.html#method-c-repack","(p1, p2, p3)","<p>Take a string of bytes which represent MATLAB data type values and repack\nthem into a string of bytes …\n"],["repacked_data","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-repacked_data","(to_dtype = nil)","<p>Unpacks and repacks data into the appropriate format for NMatrix.\n<p>If data is already in the appropriate …\n"],["repacked_indices","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-repacked_indices","()","<p>Unpacks and repacks index data into the appropriate format for NMatrix.\n<p>If data is already in the appropriate …\n"],["rot","NMatrix::BLAS","NMatrix/BLAS.html#method-c-rot","(x, y, c, s, incx = 1, incy = 1, n = nil, in_place=false)","<p>Apply plane rotation.\n<p><strong>Arguments</strong> :\n<p><code>x</code> -&gt; NMatrix\n"],["rot!","NMatrix::BLAS","NMatrix/BLAS.html#method-c-rot-21","(x, y, c, s, incx = 1, incy = 1, n = nil)","<p>Apply plane rotation directly to <code>x</code> and <code>y</code>.\n<p>See rot for arguments.\n"],["rotg","NMatrix::BLAS","NMatrix/BLAS.html#method-c-rotg","(ab)","<p>Apply givens plane rotation to the coordinates (a,b), returning the cosine\nand sine of the angle theta. …\n"],["row","NMatrix","NMatrix.html#method-i-row","(row_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>row_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["row","NMatrix","NMatrix.html#method-i-row","(row_number, get_by = :copy)","<p><strong>Arguments</strong> :\n<p><code>row_number</code> -&gt; Integer.\n<p><code>get_by</code> -&gt; Type of slicing to use, <code>:copy</code> or\n<code>:reference</code>.\n"],["rows","NMatrix","NMatrix.html#method-i-rows","()","<p>This shortcut use #shape to return the number of rows (the first dimension)\nof the matrix.\n"],["rows","NMatrix","NMatrix.html#method-i-rows","()","<p>This shortcut use #shape to return the number of rows (the first dimension)\nof the matrix.\n"],["save","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save","(matrix, filename, options = {})","<p>Can optionally set :symmetry to :general, :symmetric, :hermitian; and can\nset :pattern =&gt; true if …\n"],["save_array","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save_array","(matrix, file, symmetry)",""],["save_coordinate","NMatrix::IO::Market","NMatrix/IO/Market.html#method-c-save_coordinate","(matrix, file, symmetry, pattern)",""],["seek_and_read_file_header","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-seek_and_read_file_header","()",""],["seq","NMatrix","NMatrix.html#method-c-seq","(shape, options={})","<p>Creates a matrix filled with a sequence of integers starting at zero.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or …\n"],["seq","NMatrix","NMatrix.html#method-c-seq","(shape, options={})","<p>Creates a matrix filled with a sequence of integers starting at zero.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array (or …\n"],["seq","NVector","NVector.html#method-c-seq","(size, dtype = :int64)","<p>Creates a vector with a sequence of <code>n</code> integers starting at\nzero. You can choose other types based on …\n"],["shape","NMatrix","NMatrix.html#method-i-shape","()","<p>Get the shape (dimensions) of a matrix.\n"],["shape","NMatrix","NMatrix.html#method-i-shape","()","<p>Get the shape (dimensions) of a matrix.\n"],["shuffle","NMatrix","NMatrix.html#method-i-shuffle","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle","NMatrix","NMatrix.html#method-i-shuffle","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle!","NMatrix","NMatrix.html#method-i-shuffle-21","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["shuffle!","NMatrix","NMatrix.html#method-i-shuffle-21","(*args)","<p>Re-arranges the contents of an NVector.\n<p>TODO: Write more efficient version for Yale, list. TODO: Generalize …\n"],["size","NMatrix","NMatrix.html#method-i-size","()","<p>Returns the total size of the NMatrix based on its shape.\n"],["size","NMatrix","NMatrix.html#method-i-size","()","<p>Returns the total size of the NMatrix based on its shape.\n"],["size","NMatrix","NMatrix.html#method-c-size","(shape)","<p>Calculate the size of an NMatrix of a given shape.\n"],["size","NMatrix","NMatrix.html#method-c-size","(shape)","<p>Calculate the size of an NMatrix of a given shape.\n"],["size","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-size","()",""],["size","NVector","NVector.html#method-i-size","()","<p>Shorthand for the dominant shape component\n"],["slice","NMatrix","NMatrix.html#method-i-slice","(*args)","<p>Access the contents of an NMatrix at given coordinates, using copying.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>)  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["slice","NMatrix","NMatrix.html#method-i-slice","(*args)","<p>Access the contents of an NMatrix at given coordinates, using copying.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">3</span>,<span class=\"ruby-value\">3</span>)  <span class=\"ruby-comment\"># =&gt; 5.0</span>\n<span class=\"ruby-identifier\">n</span>.<span class=\"ruby-identifier\">slice</span>(<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>,<span class=\"ruby-value\">0</span><span class=\"ruby-operator\">..</span><span class=\"ruby-value\">1</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["small?","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-small-3F","()",""],["sorted_indices","NVector","NVector.html#method-i-sorted_indices","()","<p>Returns an array of the indices ordered by value sorted.\n"],["std","NMatrix","NMatrix.html#method-i-std","(dimen=0)","<p>Calculates the sample standard deviation along the specified dimension.\n<p>This will force integer types …\n"],["std","NMatrix","NMatrix.html#method-i-std","(dimen=0)","<p>Calculates the sample standard deviation along the specified dimension.\n<p>This will force integer types …\n"],["stype","NMatrix","NMatrix.html#method-i-stype","()","<p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.\n"],["stype","NMatrix","NMatrix.html#method-i-stype","()","<p>Get the storage type (stype) of a matrix, e.g., :yale, :dense, or :list.\n"],["sum","NMatrix","NMatrix.html#method-i-sum","(dimen=0)","<p>Calculates the sum along the specified dimension.\n<p>@see #inject_rank\n"],["sum","NMatrix","NMatrix.html#method-i-sum","(dimen=0)","<p>Calculates the sum along the specified dimension.\n<p>@see #inject_rank\n"],["supershape","NMatrix","NMatrix.html#method-i-supershape","()","<p>Get the shape of a slice&#39;s parent.\n"],["supershape","NMatrix","NMatrix.html#method-i-supershape","()","<p>Get the shape of a slice&#39;s parent.\n"],["symmetric?","NMatrix","NMatrix.html#method-i-symmetric-3F","()","<p>Is this matrix symmetric?\n"],["symmetric?","NMatrix","NMatrix.html#method-i-symmetric-3F","()","<p>Is this matrix symmetric?\n"],["to_a","NMatrix","NMatrix.html#method-i-to_a","(dimen=nil)","<p>Converts an NMatrix to an array of arrays, or an NMatrix of effective\ndimension 1 to an array.\n<p>Does not …\n"],["to_a","NMatrix","NMatrix.html#method-i-to_a","(dimen=nil)","<p>Converts an NMatrix to an array of arrays, or an NMatrix of effective\ndimension 1 to an array.\n<p>Does not …\n"],["to_a","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-to_a","()",""],["to_f","NMatrix","NMatrix.html#method-i-to_f","()","<p>Converts an nmatrix with a single element (but any number of dimensions)\n\n<pre>to a float.</pre>\n<p>Raises an IndexError …\n"],["to_f","NMatrix","NMatrix.html#method-i-to_f","()","<p>Converts an nmatrix with a single element (but any number of dimensions)\n\n<pre>to a float.</pre>\n<p>Raises an IndexError …\n"],["to_flat_a","NMatrix","NMatrix.html#method-i-to_flat_a","()",""],["to_flat_a","NMatrix","NMatrix.html#method-i-to_flat_a","()",""],["to_flat_array","NMatrix","NMatrix.html#method-i-to_flat_array","()","<p>Converts an NMatrix to a one-dimensional Ruby Array.\n"],["to_flat_array","NMatrix","NMatrix.html#method-i-to_flat_array","()","<p>Converts an NMatrix to a one-dimensional Ruby Array.\n"],["to_h","NMatrix","NMatrix.html#method-i-to_h","()",""],["to_h","NMatrix","NMatrix.html#method-i-to_h","()",""],["to_hash","NMatrix","NMatrix.html#method-i-to_hash","()","<p>Create a Ruby Hash from an NMatrix.\n"],["to_hash","NMatrix","NMatrix.html#method-i-to_hash","()","<p>Create a Ruby Hash from an NMatrix.\n"],["to_nm","Array","Array.html#method-i-to_nm","(shape, dtype = nil, stype = :dense)","<p>Convert a Ruby Array to an NMatrix.\n<p>You must provide a shape for the matrix as the first argument.\n<p>Arguments: …\n"],["to_nm","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-to_nm","(dtype = nil)","<p>Create an NMatrix from a MATLAB .mat (v5) matrix.\n<p>This function matches the storage type exactly. That …\n"],["to_ruby","NMatrix::IO::Matlab::Mat5Reader","NMatrix/IO/Matlab/Mat5Reader.html#method-i-to_ruby","()",""],["to_ruby","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-to_ruby","()",""],["to_ruby","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-to_ruby","()","<p>Figure out the appropriate Ruby type to convert to, and do it. There are\nbasically two possible types: …\n"],["to_s","NMatrix::IO::Matlab::Mat5Reader::ElementDataIOError","NMatrix/IO/Matlab/Mat5Reader/ElementDataIOError.html#method-i-to_s","()",""],["transpose","NMatrix","NMatrix.html#method-i-transpose","()","<p>Copy constructor for transposing.\n"],["transpose","NMatrix","NMatrix.html#method-i-transpose","()","<p>Copy constructor for transposing.\n"],["unpacked_data","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-unpacked_data","(real_mdtype = nil, imag_mdtype = nil)","<p>Unpacks data without repacking it.\n<p>Used only for dense matrix creation. Yale matrix creation uses\nrepacked_data. …\n"],["upcast","NMatrix","NMatrix.html#method-c-upcast","(p1, p2)","<p>Given a binary operation between types t1 and t2, what type will be\nreturned?\n<p>This is a singleton method …\n"],["upcast","NMatrix","NMatrix.html#method-c-upcast","(p1, p2)","<p>Given a binary operation between types t1 and t2, what type will be\nreturned?\n<p>This is a singleton method …\n"],["variance","NMatrix","NMatrix.html#method-i-variance","(dimen=0)","<p>Calculates the sample variance along the specified dimension.\n<p>This will force integer types to float64 …\n"],["variance","NMatrix","NMatrix.html#method-i-variance","(dimen=0)","<p>Calculates the sample variance along the specified dimension.\n<p>This will force integer types to float64 …\n"],["vector?","NMatrix","NMatrix.html#method-i-vector-3F","()","<p>Shortcut function for determining whether the effective dimension is 1. See\nalso #nvector?\n"],["vector?","NMatrix","NMatrix.html#method-i-vector-3F","()","<p>Shortcut function for determining whether the effective dimension is 1. See\nalso #nvector?\n"],["write","NMatrix","NMatrix.html#method-i-write","(*args)","<p>Binary file writer for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["write","NMatrix","NMatrix.html#method-i-write","(*args)","<p>Binary file writer for NMatrix standard format. file should be a path,\nwhich we aren&#39;t going to check …\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Compressed","NMatrix/IO/Matlab/Mat5Reader/Compressed.html#method-i-write_packed","(packedio, options = {})","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Element","NMatrix/IO/Matlab/Mat5Reader/Element.html#method-i-write_packed","(packedio, options)",""],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Header","NMatrix/IO/Matlab/Mat5Reader/Header.html#method-i-write_packed","(packedio, options)","<p>TODO: TEST WRITE.\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::MatrixData","NMatrix/IO/Matlab/Mat5Reader/MatrixData.html#method-i-write_packed","(packedio, options)","<p><strong>Arguments</strong> :\n<p>++ -&gt;\n\n<p><strong>Returns</strong> : -\n"],["write_packed","NMatrix::IO::Matlab::Mat5Reader::Tag","NMatrix/IO/Matlab/Mat5Reader/Tag.html#method-i-write_packed","(packedio, options)","<p>TODO: TEST WRITE.\n"],["yale?","NMatrix","NMatrix.html#method-i-yale-3F","()",""],["yale?","NMatrix","NMatrix.html#method-i-yale-3F","()",""],["yale_a","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_a","(p1 = v1)","<p>Get the A array of a Yale matrix (which stores the diagonal and the LU\nportions of the matrix).\n"],["yale_d","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_d","(p1 = v1)","<p>Get the diagonal (“D”) portion of the A array of a Yale matrix.\n"],["yale_ia","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ia","()","<p>Get the IA portion of the IJA array of a Yale matrix. This gives the start\nand end positions of rows …\n"],["yale_ija","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ija","(p1 = v1)","<p>Get the IJA array of a Yale matrix (or a component of the IJA array).\n"],["yale_ja","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja","()","<p>Get the JA portion of the IJA array of a Yale matrix. This gives the column\nindices for entries in corresponding …\n"],["yale_ja_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row.\n"],["yale_ja_d_keys_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_at","(i)","<p>Returns the diagonal and non-digonal column indices stored in a given row.\n"],["yale_ja_d_keys_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_set_at","(i)","<p>Returns the diagonal and non-diagonal column indices stored in a given row.\n"],["yale_ja_d_keys_sorted_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_d_keys_sorted_set_at","(i)","<p>Returns the diagonal and non-diagonal column indices stored in a given row.\n"],["yale_ja_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_set_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row, as\na Set.\n"],["yale_ja_sorted_set_at","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_ja_sorted_set_at","(i)","<p>Returns the non-diagonal column indices which are stored in a given row, as\na Set.\n"],["yale_lu","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_lu","()","<p>Get the non-diagonal (“LU”) portion of the A array of a Yale matrix.\n"],["yale_nd_row","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row","(p1, p2 = v2)","<p>This function gets the non-diagonal contents of a Yale matrix row. The\nfirst argument should be the row …\n"],["yale_nd_row_as_array","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_array","(i)",""],["yale_nd_row_as_hash","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_hash","(i)","<p>Returns the non-diagonal column indices and entries stored in a given row.\n"],["yale_nd_row_as_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_set","(i)",""],["yale_nd_row_as_sorted_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_as_sorted_set","(i)",""],["yale_nd_row_size","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_nd_row_size","(i)","<p>Returns the size of a given non-diagonal row.\n"],["yale_row_as_array","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_array","(i)",""],["yale_row_as_hash","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_hash","(i)","<p>Returns the diagonal and non-diagonal column indices and entries stored in\na given row.\n"],["yale_row_as_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_set","(i)",""],["yale_row_as_sorted_set","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_row_as_sorted_set","(i)",""],["yale_size","NMatrix::YaleFunctions","NMatrix/YaleFunctions.html#method-i-yale_size","()","<p>Get the size of a Yale matrix (the number of elements actually stored).\n<p>For capacity (the maximum number …\n"],["zeroes","NMatrix","NMatrix.html#method-c-zeroes","(shape, opts = {})",""],["zeroes","NMatrix","NMatrix.html#method-c-zeroes","(shape, opts = {})",""],["zeroes","NVector","NVector.html#method-c-zeroes","(size, dtype = :float64)",""],["zeros","NMatrix","NMatrix.html#method-c-zeros","(shape, opts = {})","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array …\n"],["zeros","NMatrix","NMatrix.html#method-c-zeros","(shape, opts = {})","<p>Creates a new matrix of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>shape</code> -&gt; Array …\n"],["zeros","NVector","NVector.html#method-c-zeros","(size, dtype = :float64)","<p>Creates a new vector of zeros with the dimensions supplied as parameters.\n<p><strong>Arguments</strong> :\n<p><code>size</code> -&gt; Array …\n"],["zeros_like","NMatrix","NMatrix.html#method-c-zeros_like","(nm)","<p>Creates a new matrix of zeros with the same stype, dtype, and shape as the\nprovided matrix.\n<p>@param [NMatrix] …\n"],["zeros_like","NMatrix","NMatrix.html#method-c-zeros_like","(nm)","<p>Creates a new matrix of zeros with the same stype, dtype, and shape as the\nprovided matrix.\n<p>@param [NMatrix] …\n"],["CONTRIBUTING","","CONTRIBUTING_md.html","","<p>NMatrix is part of SciRuby, a collaborative effort to bring scientific\ncomputation to Ruby. If you want …\n"],["History","","History_txt.html","","<p>0.0.1 / 2012-04-10\n<p>1 major enhancement\n<p>Initial alpha release\n"],["LICENSE","","LICENSE_txt.html","","<p>This version of SciRuby is licensed under the BSD 2-clause license.\n<p>sciruby.com\n<p>github.com/sciruby/sciruby/wiki/License …\n"],["README","","README_rdoc.html","","<p>NMatrix\n<p>Fast Numerical Linear Algebra Library for Ruby\n<p>sciruby.com\n"],["binary_format","","ext/nmatrix/binary_format_txt.html","","<p>This is the proposed binary format for saving and loading NMatrix objects.\n<p>Order is little-endian.\n<p>List …\n"]]}}